00:01:15 DAVID J. MALAN: All right, this is CS50. And this is week 2 our third together. Last week, of course, we introduced C on the heels of Scratch. And it might have indeed felt like things escalated quickly. But that's really because there was a lot of new syntax, especially if you've never programmed before. But keep in mind, that vis-a-vis what we did in week 0, there weren't that many new ideas. Last week, we just translated them literally to another language. There were still functions and loops and conditionals and variables and things like that, even though the syntax was, and will remain for some time until you get ample practice under your belt, quite different. Now, today, what we're going to do is try to take some of the magic out of what we did last week. So even though it might have seemed complicated, there was some sort of magic. Somehow, you write some code. 

00:02:01 You literally type make and then Enter, and a program somehow gets made, assuming there's no errors within the code. Well, today we'll take the hood off of that process, give you a better sense of what's going on, because at the end of the day, and by the end of the course, there really won't be any surprises. And even if you won't feel an expert at every little detail, you'll at least have this bottom up understanding of what's going on, so that once you're out of this class and in the real world, and maybe dabbling or doing full-time programming, you'll have a much better technique and mindset for actually solving real-world problems. So in fact, one of the real world problems we thought we'd begin with today is a specific domain like this, like reading levels. So if you look at a block of text, at what reading level is someone reading? Is it maybe kindergarten, first grade, middle school, high school, or the like? There's certainly a range there. And while all of us might have an instinct for what makes something easy to read versus harder to read, we'll see this week if we can't quantify that a little bit. And I thought we'd do this by way of some examples. In fact, if we could give us some mood lighting here, 

00:03:01 we'll introduce three of our volunteers, who stood up early in class. If you'd like to each say hello. STUDENT: Hello. I'm Eric. I'm from Philadelphia. And I'm in Hollis Hall. STUDENT: Hi. I'm Elizabeth. I'm from Baltimore. And I'm also in Hollis Hall. DAVID J. MALAN: But no one else seems to be from Hollis Hall this year. OK STUDENT: I'm Jesse. I'm from South Florida. And I'm in Canaday. [CHEERING] DAVID J. MALAN: Wow-- all Canaday. All right, so the first exercise we thought we'd do is, have Eric open the envelope that he has in front of him, inside of which is a reading snippet from a book with which many of you might be familiar. And we'll ask Eric to read this aloud, and then we'll ask you at what level Eric seems to read. He's turning on the POV glasses. We'll give you the microphone and read away. STUDENT: "One fish, two fish, red fish, blue fish." DAVID J. MALAN: Wonderful to Eric. 

00:04:00 So at what level would you say that Eric is currently reading? Yeah. STUDENT: First grade. DAVID J. MALAN: First grade. And why first grade? STUDENT: The words are really simple. There's not much complexity. DAVID J. MALAN: Yeah so the words are really simple. There's not much complexity. And if look at it textually, there is indeed very short sentences, very few words in each. And so if we adopt a heuristic, we could assume that this probably suggests with high probability that this is a lower reading level. And in fact, the correct answer, at least according to an algorithm you will explore in problem set 2 this week, is actually before grade 1, so maybe kindergarten or the like. But let's go ahead and do a second example here if, Elizabeth, you could read one of your favorite texts. STUDENT: "Congratulations. Today is your day. You're off to great places. You're off and away." DAVID J. MALAN: All right, so also Doctor Seuss. And does someone want to conjecture at what level Elizabeth reads? STUDENT: Advanced. DAVID J. MALAN: Advanced. OK, so give me a number, though. A grade level, perhaps. More advanced, for sure. Someone else. Yeah, in the middle. 

00:05:00 STUDENT: Third grade. DAVID J. MALAN: So third grade. And why. What's your instinct behind that? STUDENT: Still shorter sentences but longer words. DAVID J. MALAN: So still shorter sentences, but longer words. And indeed, the right answer, at least according to one measure, is indeed amazingly third grade. So let's do one final one with Jesse here, if you want to read your favorite text for us, turning on your second pair of glasses. STUDENT: "It was a bright, cold day in April and the clocks were striking 13. Winston Smith, his chin nuzzled into his breast in an effort to escape the vile wind, slipped quickly through the glass doors of Victory Mansions, though not quickly enough to prevent a swirl of gritty dust from entering along with him." DAVID J. MALAN: All right, and one final query of the audience. At what grade level does Jesse seem to read? STUDENT: 10th. STUDENT: Ninth. DAVID J. MALAN: 10th, ninth. STUDENT: 11th DAVID J. MALAN: 11th, STUDENT: 12th. DAVID J. MALAN: 12th. OK, so we're trying all numbers. The correct answer, according to one measure, is indeed 10. 

00:06:00 And why, you probably have an instinct for-- much longer words, longer sentences, full paragraph. And indeed that would seem to correlate with a higher reading level, indeed. But if we go back for just a moment-- you can see this with your human eyes at a glance. But if this were actually digital, like in a Word document, a Google document, or a very simple text file, how could you actually go about writing code that applies the heuristics that came intuitively to all of you here, and actually spit out with printf, for instance, and see an actual number? So that's going to be among the goals for this coming week's problem set. In the meantime, maybe round of applause for our three volunteers. [APPLAUSE] So beyond reading levels, we thought we'd explore this week other problems as well. And in fact, very much current and omnipresent nowadays is the art, the science of cryptography, the art of scrambling information, so as to communicate securely. Whether it's a private message you want to send, or maybe credit card information, or a password or the like, among the challenges for this week two after this week's introduction is going 

00:07:03 to be to apply these lessons to actually building some form of cryptography yourself. And here, for instance, is an example of a message, so-called ciphertext, that's been encrypted, that is scrambled somehow to make it harder to read. Now, there is a bit of a hint baked into this. It's not the most sophisticated algorithm, but does anyone want to conjecture what this secret message would seem to say? STUDENT: CS50. DAVID J. MALAN: So it does happen to say, this is CS50. And indeed, we're leaking information there. But why is it this is CS50? Well, you might have guessed that it has the right number of letters and words. But what comes before U? T. What becomes before I? H. What becomes what comes before J? I, and so it's not just random. It seems there's a pattern here. And insofar as if we keep playing that game, each of the letters on the screen is one away, rotated or shifted from the actual letter I claim it represents. I bet using some very simple arithmetic, we could write code to do just that. 

00:08:01 But what we don't yet have in our toolkit, so to speak, is the ability to manipulate text in programs, the ability to manipulate what we called last week strings. We could print a string like "Hello, world." We could get a string like David, but we didn't necessarily have the ability to analyze it letter by letter or do more interesting things with it. And that, of course, is what the whole world does when analyzing text, searching a database, searching the web itself, is actually analyze some of the text on the screen. We'll equip you with exactly that, so it will become clear, among other things, why this indeed says this is CS50. So how do we get there? Well, first let's understand some of the magic that took place last week. And recall that this was the process that was distilled into a very simple command, literally make-- make hello, make Mario, or whatever program you're trying to make. The input to that process was source code. It might still look cryptic to you, but it's at least English-like. The output of that process was machine code, zeros and ones, that really makes no sense to humans unless you pull out a paper, pencil 

00:09:00 and somehow convert it back to something else. But the compiler is the algorithm, step-by-step instructions for converting source code to machine code embodied in a program that you can run. So that was compilation, converting or translating source code to machine code. And the code, of course, that we played with mostly last week was something like this-- simplest program you can perhaps write in C, simply to print out "Hello, world." But the computer, of course, only understands the corresponding zeros and ones. So how do we actually get from source code to machine code? That is to say, what's actually happening underneath the hood when you run a command like make? Well, up until now, you literally, after making a file, like hello.c, you would type make hello, cross your fingers, hope there's no syntax errors, no typos of any sort. And then to run it, you would do ./hello. It's a little weird that you have to do that, but dot means the current folder, and dot slash means run the program called Hello in the current folder. This is the command line interface equivalent 

00:10:03 of double-clicking an icon on your Mac or PC, or tapping an icon on your phone. It just runs it with the keyboard instead. But I did reveal briefly last week that Make is not actually a compiler. It is a program. It is a useful program. But it automates the process of running an actual compiler for you. What is that compiler? Well, there's many different compilers in the world, but the one we use in class that's free and open source and therefore very popular in the world is actually called Clang, for C language. And so really what's happening when you run make hello, or any other such command, is that make in turn is running another program for you called Clang. The catch, though, is that this program by default is not nearly as user-friendly. It doesn't say what it does, let alone give you a useful output, because the output it gives you is actually a file by default called a.out for "assembly output," whatever that means. Which is to say, if you use Clang directly instead make 

00:11:03 don't get a program called Hello, you weirdly get a program called a.out. So let's actually see that. But then let's fix that step backwards. So here I am in VS Code. I've hidden my activity bar in the file browser, but I'm going to go ahead and run code hello.c. And I'm going to very quickly recreate last week's program with including stdio.h. And then inside of int main void, I'm going to put printf, quote unquote, "Hello, world," backslash n and a semicolon. And now, instead of running make, I'm going to do clang hello.c, Enter. So notice I did do clang hello.c the name of the file. I didn't just say make hello the name of the program. So that's one change here. And now, what was actually made? Well, what was the command for listing files in a folder? STUDENT: ls. DAVID J. MALAN: So ls for list. And you'll see that not only do I have hello.c there, I also have a.out. 

00:12:00 And in fact, if I open up my File Explorer at left, there are those same two files-- hello.c and a.out. So hereon after it's all the same-- dot a.out enter still works as exactly as I intend. It's just a stupid default name for a file. So how do we go about making this program just more user-friendly, more aptly named. Well, instead of running Clang, and then the name of the file, we can actually provide more arguments to Clang. And I haven't used this term in this context before, but there's a new term of art we'll explore today called command line arguments. And all that means is that, when you run a command in your terminal window, you can type not only the name of the command or program you're running, like ls or Make or Clang. You can give arguments that is input to that program. And I didn't use that phrasing last week. But when you run, for instance, make hello, the command line argument you're passing to make is indeed hello. And if there was a second word, that would be another argument, a third word, that'd be a third argument, and so forth. 

00:13:00 So command line arguments are inputs provided to commands at the so-called command line in your terminal window. So that's it, just a term of art. But instead of running make hello I just ran, of course, clang hello.c. That gave me the wrong file name as output. But there is a fix here. We simply need to know from its documentation, from a class, from a book, what other command line arguments Clang supports. And indeed, if I look that up or pay attention here, I can somewhat cryptically change my command to be clang -o in lowercase hello, then hello.c. And this is a very common technique in command line environments, whereby when you want to modify the behavior of the program by providing more arguments, you use things like flags or switches here, called different things by different people. But -o means output a file called hello when you compile hello.c. Eventually you memorize these things. But it's not intellectually interesting, other than this is how you can provide not one, 

00:14:02 but now three arguments to a program. Then that gives you indeed ./hello, so let me go ahead and do that. I'm going to go ahead now and clear my terminal window. Run now clang -o hello, and then hello.c Enter. Similarly, nothing seems to happen. If I type ls now, though you'll see three files. And in fact, /hello works exactly as it did last week. In fact, I don't need a.out, so there's different ways to delete things. I could go into my File Explorer. I could right click or Control click and select Delete explicitly. Or we didn't see this last week, but you might have learned it since, you can actually do rm, for remove, a.out, Enter. And even though this is a little verbose, remove regular file a.out, it's just asking you now for y or n, for Yes or No. And I can say Y, Enter. And now if I run ls one more time, I'll see just those two files. So that's how I might remove or delete a file. 

00:15:00 Obviously, just be careful when doing that if the file is otherwise important. So let me pause here and see if there's any questions on what we just did or what a command line argument actually is. Soon today, you'll have the ability to use and create these things yourself in your own programs. All right, so seeing none, that doesn't feel all that compelling. So we've saved a few keystrokes. Instead of typing make and instead of typing clang, I have to do -o hello. But that's again one of the upsides make. It's fine. It's not that hard to do -o hello. But why bother when you can use another program, Make, to automate that process for you and just save you time? And indeed, that's what these command line environments are all about, just saving the programmer or the technical person time as you get better and better with these things. All right, but now let's consider another ramification of what Make actually does for us by taking a look, for instance, at this same program, but consider what's going on underneath the hood step by step if we add a couple of more lines of code. 

00:16:02 So recall that the second program we wrote using C last week was this, whereby I added the CS50 library. And then I used a function we wrote for you called get_string. I stored the return value of get_string in a variable called name, for instance, of type string. And then we use this placeholder technique last time, whereby I plugged in the value of the person's name based on whatever they themselves typed in. Now, there's a lot going on here. But today, we'll peel back the layers of what's happening line by line and why we have to keep typing stuff like this at the top. Well, recall that when you compiled that program last week, all you had to do was run make hello. But that's because whenever you use third-party libraries, code that other people wrote, like CS50, then these commands, when you use Clang directly, just get slightly more annoying. If you want to compile that program from last week with Clang directly, you can do -o hello to specify the file name. 

00:17:00 You have to specify hello.c to compile that file. But now, somewhat annoyingly, you have to do -lcs50, no space in-between, to specify that you want to use the library called CS50. Why? Because that's specific to us. It's not globally available in the whole world, so the system doesn't know about it, unless we've pre-installed it. So this just tells it to support the CS50 library as well. Now, as an aside, some of you for problem set 1 probably used the math library, maybe to round some values or something like that. It turns out that you can also do -lm in order to use the math library. But the math library is so darn popular, and it actually comes with C, that you don't have to actually do -lm. But it's the same idea. It's just so common that they automate that process for you. But for third-party libraries, you have to do this. Now, at this point, this is really starting to increase the tedium of compiling your code. This is why we just say make hello last week, which automates the process of generating hidden for you this entire command underneath the hood. 

00:18:03 But that is what's happening to get a file called ./hello. So we're back to where we began. But what does it actually mean now to be compiling this code in the first place? So we keep saying, and I will keep saying, to compile your code, to compile your code, to translate source code to machine code. But that's actually an abstraction, so to speak. It's like a simplification of a multi-step process that the computer's actually doing for you. And this too will be briefly a deeper dive to look at this lower level of what's going on. But then again, after today, we can take for granted that this just works. But you'll understand hopefully better what's really happening underneath the hood. So again, there's no magic. So it turns out that when you run Make, and in turn it runs Clang, four separate things are happening, each of which does something a little different for you-- preprocessing, actual compiling, assembling, and linking. It's just the world combines all four of these terms into "compiling" by convention. So let's consider the first of these. What does it mean to preprocess a file? Well, even though we haven't used this word before, 

00:19:01 here's one of the programs we wrote last week. It was a little longer, but this was a program that three times, called a meow function, which I had ultimately implemented quite simply with this meow function of my own, that just says printf meow. And recall that I did a couple of things at the top of the file. I included stdio.h because I need print access to printf. But I also did this. And what did we generally call this second line? STUDENT: Prototype. DAVID J. MALAN: Sorry? STUDENT: Prototype. DAVID J. MALAN: A prototype. The prototype was just the first line of a function, semicolon. So nothing in between the curly braces. And recall that that's just a hint to the compiler that this function doesn't exist as of line 2. But I promise, it eventually will. And that was to avoid having to move the whole function from the bottom of the file to the top, because you can imagine, once you have three, four, 30, 40 functions, it's probably going to be hard to put all of them above the other. So this is a way to just tell the compiler in advance to expect that this thing will exist. 

00:20:03 So what is now going on in the very first step of compiling? Well, we called it preprocessing. And anything that starts with a hash sign like this is what's technically called a preprocessor directive. Now, a big mouthful, but that just says that there's something in that file that you want to get essentially copy-pasted into this one. So what's really happening now is-- and let's actually consider-- sorry, let me double back here. Let's actually consider a simpler example for a moment, namely the second program, again, whereby we used get_string to get the human's name, and we just said "hello" to them. This one had two preprocessor directives. So let's consider what's actually happening here. What did we say was inside of cs50.h last week. STUDENT: Get_string. DAVID J. MALAN: Get_string, but more specifically the prototype for get_string, a little bit of a hint that tells the compiler what it looks like, what's its name, what's its input or arguments, and what's its output or return values. So this file, technically, when you run the pre-processing step, 

00:21:02 compiler goes into that file, CS50-- finds the relevant code, and essentially copy-pastes it into this current file. And in fact, it's not even that sophisticated. It essentially copy-pastes the entirety of cs50.h at the top of your code, so you don't have to manually copy-paste anything yourself. Meanwhile, this second line, stdio.h, this of course, is there for printf sake. But printf has a prototype. It's got a name, it's got inputs, it's got outputs. So that you don't have to go and find that file and copy-paste it, the pre-processing step goes into that file for you, finds the relevant code and some other stuff, and effectively copies and pastes it there as well. That then is pre-processing. It just saves you time so that you can reuse functions that someone else, besides you, perhaps wrote, and use and reuse them and automate the copy-paste process. Anything starting with a hash sign therefore gets pre-processed. OK, what happens next? The compiling step, which is, again, the catch-all term for all of this. 

00:22:00 But when we say your program is being compiled, what we mean now is this. Here's that same code after it has been pre-processed. And when you actually compile this code, this means it gets translated from one language, C in this case, to another language we haven't talked about. And after today, we're not really going to talk about it, but it gets translated from C into something crazy-looking called assembly code. And now if you take other courses in computer science-- lower-level courses, so to speak, you'll actually learn a language that looks a little something like this, which at a glance is even more cryptic than C, which is why we don't spend all that much time on it in this class. But there are some interesting terms that I can highlight here. So even in this weird-looking language called assembly, there's a mention of main, there's mention of get_string, and there's mention of printf. And there's some other things worth highlighting here. They're a little more arcane. But there's some mention of pushing, moving, subtracting, calling, and so forth, even though there's some other letters like q in there as well. But it turns out that inside of your computer 

00:23:03 is that CPU, the central processing unit, Intel m or M1 or M2 or M3 from Apple. Those CPUs, the brains of your computer, at the end of the day, they don't understand. C, they don't understand Scratch. They do understand zeros and ones, but what they really understand are specifically these commands. These commands have corresponding patterns of zeros and ones. But if you're actually building a computer, and you get the manual from Intel, there will be documentation for all of the low-level commands, the instructions that an individual CPU actually supports. And this might differ between Macs and PCs and phones and other devices. But this is what happens when you compile your code from C into this lower-level language called assembly code. All right, we'll never again see this, I think, for the most part. So what's the third step? The third step is to finally convert the assembly code to actual zeros and ones, because that's indeed what the computer understands. So here is that exact same assembly code. Once it is assembled, that means the computer 

00:24:01 outputs this, which most humans wouldn't understand, unless again, they pull out that same manual. But the computer will understand this. And the very last step is what's called linking. So what do we mean by linking? Well, take a look at this code again. And just from inference, how many files are presumably involved in the process of compiling this whole thing? And I mean compiling in the greater sense, like going from source code to zeros and ones total. How many files are implied by this screenshot? STUDENT: Three. DAVID J. MALAN: OK, three. Why three. I saw two here. But why three? STUDENT: Because the main program. DAVID J. MALAN: The main program, like hello.c. STUDENT: Yeah, and then cs50.h. DAVID J. MALAN: cs50.h, and of course stdio.h. So there's three different files involved in even compiling the simplest of programs like this. Now, I'll stipulate that somewhere on the server's hard drive, there is not only a .h file, which has those prototypes. There's also a cs50.c file. 

00:25:02 There's also a stdio.c file as well, which contains all of the actual code that we or other people wrote. It's not necessarily called exactly that, but there are C files containing all of those lines of C code. So what really happens now in the fourth and final step of building your program, compiling your program is this-- hello.c cs50.c, and stdio.c, wherever the latter two are on the server. We pre-installed all this stuff for you. You only wrote in this story this file. When you finally compile, and once you have pre-processed, compiled, and assembled your files, you essentially have three sets of zeros and ones, each of which corresponds to each of those files. This is the code you wrote, once it's compiled to zeros and ones. This is the code that CS50 wrote. This is the code that came with C stdio.c itself. So the fourth and final step is literally linking. What does it mean? Well, you've got three sets of zeros and ones. You've got to somehow mash them together, link them together. And linking does exactly that. 

00:26:02 So this is such a mouthful to say that you write C code, and it ends up zeros and ones. But each of the steps can be very cleanly broken down like that, so you understand exactly what's going on underneath the hood. And now if you consider the command we talked about earlier, -o just specifies what file the linker outputs at the end of the day. Is it Hello? Is it a.out? Is it something else? And -lcs50 more specifically, doesn't just mean -l library, it means -l link, so link in CS50's library to ensure you have access to those zeros and ones. You don't have to do it for math. You don't have to do it for std I/O. But you do have to do it for third-party code that other people altogether wrote for you. Whew, OK, done with that deep dive. Questions, confusion, on any and all of that? Yeah, in the front. STUDENT: Are there ways to import art stuff like, let's say CS50? 

00:27:01 Like, if I'm not going to use a lot of things that's written in the CS50 file, but I only want one function, is there a way to just pull out just one thing? DAVID J. MALAN: A really good question. If you only want access to one function, and not all of them in a library like CS50's, can you extract just a subset. It depends. The compiler ideally would do some of that for you, and it would only dynamically link in what you actually need. If, though, by default you statically link everything, and you get all of the zeros and ones, this is actually now a more sophisticated answer to a question someone asked here last week, which was about the efficiency of all of this. And unfortunately, by default, you would typically get bigger and bigger files if you're linking in too much stuff unnecessarily. So yes, that's absolutely an optimization that is possible, but the compiler should be handling most of that for you, not you, the programmer, generally worrying about it. Yeah. STUDENT: In your prototype for the printf function, why was there, like, an int before that. DAVID J. MALAN: Oh, really good question. In the prototype for printf, why was there an int before? Let me come back to that. And we'll talk a little bit about something related in spirit today. 

00:28:00 Main, actually, all this time also has the word int in front of it. We'll explain that one first. All right, so what can we take, then, away from this? Well, if that is all compiling can we actually reverse the process? Can you go about decompiling code? That is to say, if you have a program installed on your computer or your phone, and it therefore contains all these zeros and ones, can you maybe reverse engineer it-- that is, convert it back to source code? Well, is that possible-- well, sort of. In fact, here's an example of a program written in C that's already been compiled down into machine code. And by compiled, I mean it's already been pre-processed, compiled, assembled, and linked. And these are the zeros and ones. Well, it turns out that if you break these zeros and ones up into chunks of, like, eight or maybe 32 or 64, you could very tediously, or using some software to automate the process, look up in Intel's manual what all of those patterns of zeros and ones represent. And you probably could reconstruct the fact that, you know what? I bet this thing says "Hello, world." 

00:29:02 Like there's enough pattern in there to figure out something like that. And surely if it says "Hello, world," we could generate source code that does the exact same thing. But what if there's some kind of loop in there, and "Hello, world" is actually getting printed two times or three times or four times, or an arbitrary number of times? I don't know if I could decompile the code quite as effectively. Why? Well, once I have it down to the levels of zeros and ones, I don't know if the programmer used a while loop, a for loop, a do while loop. There's ambiguity in that process ultimately. So while you can reverse some processes, at some point, it becomes harder or ambiguous to do so. And this is a relatively short program, even though there's some more zeros and ones not pictured. When you're talking about something like Microsoft Word or Excel, there are millions of zeros and ones inside of that. And honestly, in the amount of time it would take you to figure out tediously what those zeros and ones correspond to in C, or some other language, you're probably smart enough to just start writing the program yourself in the other direction. 

00:30:01 And that's the supposition when it comes to intellectual property and protecting your software's IP rights. The reality is, like the people who are going to be so good as to reverse engineer it probably could just recreate the software itself. So there's a bit of pushback there inherent. But later in the term, we're going to talk about other languages-- HTML, CSS, and JavaScript. That stuff is not compiled into zeros and ones in any way like this. So that code is actually revealed to literally anyone on the internet. We could go on Harvard or Yale's website right now, look at the JavaScript code that powers parts of it, and actually see what's going on. But more on that in just a few weeks' time. So today is all about debugging ultimately, too-- like finding and fixing mistakes in your code. And debugging actually does indeed mean removing mistakes from your code. There is mythically a story behind that. So this is Rear Admiral Grace Hopper from the United States 

00:31:02 Navy, who had her PhD from Yale, and actually is known for many things, but among them is for working on the Harvard Mark I computer that looks a little something like this in black and white. It's now housed across the river in the Science and Engineering Complex at Harvard, which you can visit if you hop across the river someday. But in the Harvard Mark II, another successor to this large mainframe computer, Dr. Hopper was responsible for keeping the log book. And pictured here is, if we zoom in here, the first actual case of a bug being found. Some kind of moth was physically found inside of the Harvard Mark II, disrupting its operations. And that's not literally what we mean, nowadays when it comes to bugs in software. And this really just popularized the term. It wasn't the origin of the term itself. But that's among the stories that gets tossed around typically when talking about bugs and, of course, debugging. So among the goals for today is to actually make your life easier when it comes to solving problems this week and onward, because odds are you were bit in the dark. 

00:32:00 If you had some mistake in your code last week, you could have, of course, asked the duck. You could have asked a teaching fellow or teaching assistant. You could have struggled through it. But let's actually give you more tools in your toolkit to solve problems. So here, for instance, was one of the simpler problems we did last week. And we'll keep it simple so we can focus on the debugging techniques and not the complexity of the code. And recall that this example was all about just printing, like, a column of bricks using hash symbols, otherwise known as ASCII art. Well, the first debugging technique we gave you, and encouraged you to use, last week was, of course, this virtual rubber duck, or even a physical rubber duck. In fact, on the way out today after class, we have not only these ducks, but hundreds of others, if you'd like to walk home to your dorms with a rubber duck and we'll bring them to those of you at Yale, you may at day's end. But the virtual version of this is, of course, powered by artificial intelligence. And not only will the duck listen to your questions, it will try as best as it can in English or some other human language to respond. But the general idea of rubber duck debugging, or rubber ducking, 

00:33:03 is to talk to an inanimate object like this, or nowadays an AI, and again, per week zero. In that process of sounding out your confusion and telling the duck, like a teaching assistant, what your problems are, odds are that proverbial light bulb will go off, and you'll realize some illogic, some mistake you've made, at which point you can actually solve it yourself. But when the problems get harder, and when the material is especially new, it's not going to necessarily come to you off the top of your head. So let's give you some more techniques. It turns out that one of the most common and useful ways to debug code is literally with a function we've used since week one printf. Because printf lets you print anything you want, including the contents of what's inside of the computer's memory, so to speak, inside of your variables and functions and the like. So let's go ahead and do this. Let me switch over to VS Code here. And let me go ahead and create a new file that deliberately is called buggy.c. So code buggy.c. 

00:34:00 And this will be relatively simple. Include stdio.h int main void. And then inside this, let me aspire to print out this column of bricks here-- of one, two, three bricks, top to bottom. All right, back in my code, I'm going to do for int, i equals 0. I want three of these, so I'm going to naively do i less than or equal to 3, i++. And then inside of a for loop, I'm going to do printf, quote unquote, hash sign backslash n, closed quote, semicolon. So if you're already pretty comfortable with C and for loops at this stage, you can probably see the bug already. But again, the focus here is on techniques, not the actual code. It looks like I've done something stupid, though, because when I do compile this code-- and I'm going to do make buggy, instead of bothering with Clang, because we now can stipulate that we know there's more going on there, but we don't need to care about it every time. ./buggy is not going to print 3. 

00:35:00 It's going to print four of those hashes instead. All right, so how do I go about wrapping my mind around what's wrong? Well, I remember from class, I'm supposed to start counting from 0 if I want to go up to 3. It's less than or equal to 3, so we could probably reason through this without much effort. But let's suppose that this is representative of more sophisticated problems. Well, printf here can be your friend. If you want to see what's going on inside of this loop, I would propose that you temporarily maybe add a second printf that says something like this. i is-- and then I'm going to use a placeholder, i backslash n, close quote, i. So if I just want to wrap my mind around what's going on every iteration of this loop, let me just literally print out the contents of that variable. So let me remake this-- make buggy, ./buggy, Enter. OK, now let me enlarge my screen. What has happened? i is 0, I get a hash. I is 1, I get a hash. i is 2, I get a hash Oh, i is 3, I get another hash. So the solution here is one of a few things. 

00:36:02 I could either regress and start counting from one. But in general, I would propose do what programmers do start counting from 0. So if I leave i at 0, what is the correct fix here? STUDENT: [INAUDIBLE]. DAVID J. MALAN: So just change it to less than 3 instead, which again is the convention, even though it's by no means the only way to do this. If I go ahead and do that, let me clear my terminal window and make it larger temporarily. Make buggy again, ./buggy. OK, now I got it. i is 0, i is 1, i is 2. And I only get hash hash hash. So printf is your friend, just remember, certainly in the context of a class like homework and the context of the real world. Once you're done using printf to debug your code, go in and delete it, so it's not printing out a confusing message to the autograder, the correctness tests, or the like there. All right, so that's how you might use something like printf. But what if I did something a little more sophisticated here? Let me do this. 

00:37:02 Let me change up this program and get rid of for loop. And let me, for the sake of discussion, just make it a little more complicated. Let me go ahead and create an integer called h for height. Let me ask the human using get_int for the height of the column of bricks that they want. I immediately have to go in and add the CS50 library, because if I want to use get_int, that comes with CS50, not with stdio.h. Once I've done this, let me go ahead and call a function that doesn't yet exist, but will-- print_column of height h. And this is where we concluded roughly in week 1, whereby I factored out some of the functionality for printing a row of bricks. Today, I'm flipping it around to say, print a column, because now I'm going to do this-- void print_column. And then the input that this will take is going to be the actual height. But I could call that anything I want, so long as it's an int. And here I'm going to recreate the correct code for int i equals 0. 

00:38:00 I less than-- not 3, but height if I want to genericize it, i++. And then inside of the loop, I'm going to go ahead and quite simply print a single hash and a new line so that it gets hash, hash, hash, hash, one per line. But there's technically a bug here. Let me hide the terminal window and scroll back up. What one mistake have I still made? STUDENT: Prototype. DAVID J. MALAN: I'm missing the prototype, because if I compile this as is, the Clang, the compiler as we now know, won't know what print_column is, because when it sees it for the first time on line 7, it has never seen it before. So the solution, of course, is to copy-paste-- and this is almost the only time copy-paste is acceptable and encouraged, that first line of the function itself. All right, let me open my terminal window. Let me run make buggy. It seems to work-- ./buggy, Enter. And it's gone ahead and done-- let's see, 3. This is the correct version. So just a bit of a sanity check that it's working as intended. Now let's break it. 

00:39:00 Let me hide my terminal window. Let me make the same mistake as before. And let me say that printf, for now, is your friend. But by week three, week four, week five, in the real world, you're not going to want to just start printing everything out, because you're going to be printing so many darn things, you're going to have to then remember to delete the stuff. It's going to mess up the output. There are better tools. And even though this week, it will take you more minutes to play with and get comfy with what I'm about to show you, this will pay off in hours over the course of the term and in the real world. Spend a few extra minutes this week playing with a proper debugger, which is going to introduce you to more sophisticated techniques for debugging your code. We are going to run now a program called debug50, which sounds CS50-specific. But that's only because it automates the process of starting VS Code's built in debugger for you. So this is not a CS50 thing. This is representative of a debugging tool you would have in the real world available to you. And VS Code is among the most popular. So let me go back to my own code here. 

00:40:01 Let me open my terminal window. And let me confirm now, by recompiling buggy, Enter, and running ./buggy, now we're back to the problem where if I type height of 3, I'm getting four hashes. So how can I wrap my mind around why that is the case without using printf? Well, what I'm going to do now is this. I'm going to run debug50. And then I'm going to run the name of the program, ./buggy So debug50 is a program that expects its own command line argument. What program do you want me to help you debug? I'm going to go ahead and hit Enter. And I made my first mistake. Looks like you haven't set any breakpoints. Set at least one breakpoint by clicking to the left of a line number, and then rerun debug50. So what is a breakpoint? Well, let me hide my terminal for just a moment. A breakpoint is sort of a stop sign that you can add to any one of your lines of code, and tell the computer break execution at that point. That is, run my code, but pause temporarily here so I can poke around. 

00:41:00 So what I'm going to do is, because the first line of juicy code is at line 8, notice if I hover in the so-called gutter of VS Code, there's this little stop sign or red dot that appears. I'm going to hover over line 8. And as directed, I'm going to click, and it gets even redder. That is a breakpoint. It says, run my code, but stop at this point so I can poke around. Let me reopen my terminal window, clear it, and do this again-- debug50 ./buggy, Enter. All right, so a whole bunch of stuff seems to be happening automatically. It's a little confusing at first glance. I'm going to zoom out just so we can see more of it here. I'm going to go back to the terminal window, because notice-- there we go. In my terminal window I have a blank window now, because why? Line 8 is about to prompt me for input. So what has happened here? Well, let me go over here to the code. This is still my buggy file. Notice that there's a Play icon here. There's some arrows. There's a Stop icon and some other stuff. 

00:42:00 Notice that line 8, as hoped, is highlighted because execution has been paused on line Let's now actually see what's going on. At the top, though, there's some curiosities. All of my variables in this program that are currently in scope-- that is, accessible between these curly braces, are summarized here. Where did 32,766 come from? Any instinct for why h apparently has this weird value, even though I haven't even typed in anything, let alone such a big number? Yeah, how about over here? STUDENT: The previous program had that number. DAVID J. MALAN: Yeah, I think that's a reasonable way to think about it. Maybe it's like a previous program used the same memory inside of the computer for something else. Maybe it was an integer. Maybe it was a string or something else. So what you're seeing is actually what we're going to start calling a garbage value. It's like remnants of what the memory was previously used for. It has no significance to us. It's not a big deal, because as soon as I let the debugger proceed one more 

00:43:01 line, the value of h is going to be changed to whatever the human actually types in. But what you're seeing is what's really going on inside the computer. You're certainly using and reusing the memory inside of your computer all day long, because you don't want to run out, so you need to reuse it. So the debugger is letting us see that. So now notice the arrows at the top of the screen. I can either hit Play to say, like, just keep running the whole program. Or I can do something like this-- Step Over. So this second arrow here, Step Over, will actually run line 8, but then pause on the next line for me. And we'll see what else we can do in a moment. So I'm going to click Step Over. And now notice, in my terminal, I have been prompted for a height. Let's go ahead and type 3, Enter. Now I've typed in 3. What happened at top left? Now the local variable, so to speak-- local in the sense that it's inside of these curly braces, is, in fact, what I would expect, which is 3. Notice now that line 9 is highlighted. It hasn't printed anything yet. 

00:44:00 So let's step over line 9, too, and see what happens with this value of h. Let me click Step Over again. The highlighted line becomes 10, which is almost at the end of the program. But unfortunately, I see 1, 2, 3, 4. Damn, like, it's still buggy in this case. And honestly, this wasn't really enlightening, setting the breakpoint there. I really have just slowed down the process of seeing my mistake. But it's still, in fact, there. So let's actually just run the program to completion. I'm going to hit the Play button. But I could just as soon hit the Stop button because they're equivalent, because the program is essentially over. All of that is going to close, but at my breakpoint is still at line 8. I'm going to do this. I'm going to leave that there. And I'm going to run debug50 once more. Let's actually step over this line as before to get my input of a height of, say, 3. But now on line 9, which is highlighted, let's not step over this, because obviously, that's just going to print out the same wrong thing instantly. Let's step into this function. Why this one? Because I wrote print_column. Ironically, I also wrote get_int. But I'm pretty sure get_int is not incorrect. 

00:45:02 I'm pretty sure print_column is incorrect, so let's step into it. The icon for that is the third icon here, the second arrow, Step Into, click. And now notice that execution has jumped into the print column function. Nothing is printed yet, because I haven't even started for loop. But now I can actually poke around here. And notice this. This is an even crazier value for i, but for the same reasons. It's just some garbage value left over from whatever this memory was being used for previously. But the moment I click Step Over now, the second icon, now notice at top left, i is 0, and we're about to print a single hash. Let me click Step Over once more. And watch the terminal window at the bottom. I currently have no hashes, but now I have one hash. Now the highlight's back on line 14. Let's step over that, and watch as I do, at top left, i is value is going to change from 0 to 1 because that value just changed. Now I'm highlighting line 16. Let's click Step Over and watch the terminal window. 

00:46:00 There's my second hash. Let's step over line 14. Watch i at top left. i equals 2. Let's go ahead and step over line 16. There's my third hash. Let's now step over line 14 again. Watch the i at top left. Here's where you can see that, oh, i equals 3. But wait a minute. Line 16 is highlighted. I'm about to execute the darn thing again. Oh, that's why I'm getting the fourth hash. And if I do this one more time, Step Over line 14, watch what happens to i. i now disappears altogether. Why? Because I've jumped out of for loop, because i became 4. we're done with that for loop. And now if I go ahead and hit Play, it's just going to run to the end of the program, which is essentially already that because the curly brace was already there. So it's tedious to walk through a program in this way. But notice, it has given me the ability to step through my code, line by line by line, at a normal person pace, not at like a Mac or PC pace, which is over in the blink of an eye. 

00:47:02 To get rid of a breakpoint, you just click on the little stop sign again. It goes away, and your code will run as usual, even in the debugger. Questions, then, on this technique of debugging? Questions? OK, use debug50. OK, use the rubber duck. That, too, should be helpful over time. But let's actually now take these ideas out for a spin and actually see what's going on in the actual computer's memory with these new techniques. So recall from last time that when you write code, you can use strings, like hello world. You can use integers like the number 50, or 72, 73, 33. That is because C, like a lot of languages, supports different types of data. And think back to week that everything is zeros and ones. How does the computer know if that's a number, a letter, a color, an image, a video, a sound? Well, it's context-sensitive. And I simplified it in week 0 and said, well, if you open something in Photoshop, the zeros and ones 

00:48:02 are going to be interpreted as colors. But that was a bit of a white lie. The better answer is, when you open in Photoshop a bunch of zeros and ones, the programmers at Adobe, the people who wrote that software, specified in the code that those zeros and ones should be treated as colors, and not as numbers and text per se. So in the world of C, there are these data types. And we had this list up last week. And we focused particularly on string and int. We introduced briefly float for real numbers with decimal points. Longs are even bigger than integers. So you don't avoid, but you at least postpone integer overflow by using more bits. And here, for instance, is how big these data types in C typically are nowadays. Technically, it varies by computer or device. But typically, it's safe to assume these values here. So a Boolean, a true or false, takes up one byte, even though that's overkill. You technically just need one bit, but C uses a full byte. 

00:49:00 An integer is typically four bytes. Four bytes is 32 bits. That means you can count from That's 0 to 4 billion, or if you want to support negative numbers, negative 2 billion to positive 2 billion. A long is 8 bytes. That's in the quintillions, depending on whether you want negatives or positive values as well. Float is 4. Double is 8. A char, a single character, is 1. That's going to be germane today. And a string, I'll propose, is unknown because it depends on how long the word is. If I type in D-A-V-I-D, it would seem to be of length 5 at first glance, or hi or just 2. A string is going to vary based on the actual contents of the memory. And here, then, is a picture of memory. So this isn't to scale at the moment, but this is what might be inside of your laptop or phone or desktop. And it would look similar in spirit, like a green circuit board or logic board with tiny little silver or gold traces that are essentially like tiny little wires that allow zeros and ones to flow back and forth. 

00:50:01 And there's these black chips that actually store the zeros and ones as your computer's memory. So if we actually zoom in on one of these black chips, I'll propose that no matter how big this chip is, I bet we could come up with addresses for all of the bytes therein. So if this thing is like 1 gigabyte, 1 billion bytes, doesn't matter how we number them. But for the sake of discussion, maybe this is the first byte. This is the second byte. This is the third byte. This is the billionth byte for gigabyte. So you could imagine, if you got this many bytes, you can slap some numbers on them. Just like on a building in the real world, you can slap a unique address on it. Like 45 Quincy Street, Cambridge, Massachusetts, 02138, USA is where we are now. In the world of memory, let's keep it simple-- So let's actually redraw this as a grid of sorts, whereby each of these squares represents a chunk of memory. So if you were to store a char in the computer's memory, that's one byte. So maybe if the human were just to type in a single character, 

00:51:02 maybe it would be stored up there in the top left corner, or who knows? Somewhere else. If you were to store an integer, which is 4 bytes, typically, maybe it would be stored there. But they are necessarily contiguous. You can't use one byte here, one byte here, one byte here. For data types like integers and strings and chars, they're all going to be back to back to back. So that's 4. What about a long, or a double for that matter? You might need 8 bytes. Those are all going to be contiguous here. Well, let's actually go ahead and abstract away the hardware, because it's not really that interesting that there's a physical circuit board. Let's think about memory more abstractly. It's just like a canvas, like in Photoshop, where every little dot can store some byte-- some set of 8 bits. Let's zoom in here and consider what could go inside of those bytes. So for instance, how about three lines of code like this? Out of context, but suppose we whip up a program real quickly that allows me to calculate my average on, like, three homework assignments or three quizzes or three exams in this class or any other. Suppose I did so-so on the first two. 

00:52:01 Score one was 72, score two was What's my average grade as of now? Well, I think we could whip this up pretty easily. For instance, let me go over to VS Code here. And let me go ahead and create a new file called-- how about scores.c? And in scores.c, I'm going to go ahead and do maybe a little something like this. Include stdio.h int main void. And inside of main, let's do int score int score 3 equals 33. And now let's just print an average. And I'm going to make a comment to myself Print average, so I remember what's going on. Comments are just for the reader not for the computer's sake. Printf average colon-- just to format it nicely. I want as many partial points as I can get, so I'm going to use a float instead of an int, backslash n. And then to compute the average, just like in the real world, 

00:53:03 I think I do score 1 plus score all divided by 3, and then a semicolon. So let's see if this works. I'm going to go down to my terminal window and do make scores, which will run Clang for me. But I screwed up already. Let me make this bigger. I'm not sure we've seen this error before. Let me rerun it more simply. What did I do wrong here, even though it's cryptic? Yeah, in back. Or just stretching? Just stretching. Yes, in there STUDENT: You're missing a parenthesis. DAVID J. MALAN: I'm missing a parenthesis. I don't think so. Not a bad instinct, but I'm not in this case, I think I'm balanced. STUDENT: The format is wrong. DAVID J. MALAN: The format is wrong. So the format code is wrong. I'm using %f, but it wants me to use %d, which technically means decimal, which is a synonym for %i for integer. But actually, no, I don't want it to be an integer. If I get partial credit, I want to be rounding up, not down, so to speak. 

00:54:00 So there's actually a more subtle error. And remember the issue last week of truncation, whereby if you've got int plus int plus int divided by int, what do you get back? You get an int. So you don't even round properly. It truncates everything after the decimal point. So one way to solve this problem would be to say, all right, really, I want to divide by 3.0. So long as you get a floating number involved, then the math will work correctly. Or I could do what I did last week too. I can cast the 3 to a float. But frankly, it's pretty equivalent and few keystrokes fewer to just say 3.0 as my denominator. And again, to be clear, the reason for that-- I don't want integer division. I want a floating point value. So if I'm getting partial credit, it's point-something that's not thrown away. All right, let's try again-- make scores, Enter. It seems to work now-- ./scores, Enter. And my average is indeed, thank to you, 59 and one third. Still kind of failed, but at least it's not 59.0 truncated down. All right, so that's one way of doing this. 

00:55:02 But what's actually now going on inside of the computer's memory? Well, here is the computer's memory, abstracted away as just squares. When I create score 1 as a variable, that's like asking the computer for four of these squares. Call it score 1, and plop, the number 72 there. When I ask for score another 4 bytes of memory, probably next to it, but not necessarily. And when I create score 3, that gives me another chunk of memory, also Again, because there's no other variables as of yet in this program, they probably will end up back to back to back. But that's not necessarily a requirement, depending on how you implement the code. Well, what is the computer really doing in the memory there? Well, it's really putting three patterns of bits-- three patterns of 32 bits, because again, by default integers tend to use 4 bytes, or So if that's what's going on inside of the computer's memory, it would seem to be correct. 

00:56:00 And indeed my math was correct. But what is badly designed about this program? It's super simple. There can't possibly be too many shortcomings. But what's bad? Yeah. STUDENT: You wanted to add more scores, you would just keep writing new variable initializations and you have to individually modify the averaging part. DAVID J. MALAN: Yeah, really well said. So if I wanted to add in more scores-- like next week, a fourth score, then a fifth score, then a sixth score, well, I can just modify the code, and add a line, line, line here. But then, I have to add like variable, variable, variable here. It's not very well maintained. And honestly, if you let your mind extrapolate, what if I've got, like, 10 scores or 100 scores over the course of years of college? Does it really seem like good design to have int score45, int score46? There's got to be a better way than coming up with these stupidly named variables where I just manually add a number, add a number, add a number. Wouldn't it be nice to just call all of them collectively scores, 

00:57:02 and not have to create individually all of these unique names? And frankly, I don't have to call them score1, score2, score3. I could have called it A, B, C, or something arbitrary like that, but that's even less clear. It would be nice to just call them all collectively one thing. Well, it turns out that there is a way to address this. And to do better than this in code, we're going to introduce the first of our data structures this week in class, whereby we can introduce the notion of an array. An array is a sequence of values back to back to back in memory. An array is a sequence of values back to back to back or contiguous in memory, all of which are the same data type. So int, int, int or char, char, char, or something else along those lines. And the syntax for creating a single variable that contains not one, but any number of values, is relatively simple in C. You simply specify what type do you want the values to be-- int. What do you want the name of the variable to be? Scores plural, just for clarity. 

00:58:01 And how many integers do you want to be associated with this variable called scores? You use square brackets, which is something new now. But the square brackets indicate, hey compiler, this is an array of three integers that will give me access to all three back to back to back in memory. So if I want to now initialize each of these values to numbers, the syntax is pretty similar to before. But I don't have to come up with new variable names for each of them. I can instead keep using this square bracket technique as follows. To initialize the first score, I can say scores bracket 0 equals 72, semicolon. The second one is scores bracket 1. The third is scores bracket 2. They are zero indexed, so to speak. As before, we're almost always going to start counting from 0 in C and in most other languages. So 0 is the first, 1 is the second, 2 is the third. But notice these aren't separate variable names. Now they're all called scores. But I am indexing into the array by jumping to a specific location-- 

00:59:01 the first one, the second one or the third one, or first, middle, last so to speak. So if I want to use this technique now, let me actually go back to VS Code here, and let me modify my version of scores as follows. I'm not going to quite do what you recommended over there a moment ago, which is to avoid repeating myself a few times. But I am going to clean this up. I'm going to say int scores bracket 3 to give me an array of three values. Then I'm going to manually say scores bracket 0 equals scores bracket 2 equals 33, semicolon. And then down here, I have to change my formula to be scores bracket 0, scores bracket 1, scores bracket 3-- sorry, scores bracket 2, and then divided by 3.0 for the same reason as before. If I open my terminal now, clear it, make scores, again seems to compile ./score. 

01:00:01 It still gives me the same value, but it's a little better-designed. I've got one variable now with three spots in it, instead of three variables-- and God forbid, even more if I want more and more of these values. Well, what is now going on in the computer's memory. Well, these three lines of code. Now look fundamentally the same-- four bytes, four bytes, four bytes. But the names that the computer is giving them is scores bracket 0, scores bracket 1, scores bracket 2. And to be clear, it's one variable. But this is saying go to the first location, location 0. Go to the second location, a.k.a., location 1. Go to the third location, a.k.a., location 2. It's a little confusing that everything's off by one, but you get used to it over time. So if that's what's going on inside of the computer's memory, let's actually tinker with it further. And toward this end of making it even better ultimately, let me propose that we go back here and maybe modify this as follows. Instead of hard-coding my three scores-- 

01:01:03 to update this code next week, and then update it in two weeks by adding more and more scores to it, what would be the right programming technique here to just prompt me again and again? STUDENT: [INAUDIBLE] DAVID J. MALAN: Like, loop again? We don't have to write all of these lines of nearly identical code. So let me do this. Let me get rid of these three lines, which look like copy-paste, except for the changing number. Let's do 4. Int i is 0. i less than 3, so I'm not going to screw up this time-- not less than or equal to but less than 3, i++. Then inside of this for loop, let's go ahead and use this syntax-- scores bracket i equals-- let's actually ask the user now for their score, rather than hard coded at all, using get_int like this. So we're using the square brackets now in a few different ways, even though the rest of the code is now the same. In this line of code, I'm declaring the variable called scores 

01:02:00 to be an array of size 3 integers. It's a mouthful, but that's all that's going on there. When I use the array later, I don't have to say int ever again. That was just to tell the computer once what types of values do I want to put in here. Hereafter, I can just say scores bracket i. Well, what is i? Well, on the first iteration of this loop, it's going to be 0, and then 1, and then 2. Like magically, it's going to plug into those square brackets. Exactly the number I want-- Get int is going to be called on how many times I loop. So I don't have to type 72, Now, the code is still imperfect. I'm still cheating that I've got the 3 here. I've got three of these here. I've got the 3 here, the 3 here. This is still poorly designed, but it's better. It's poorly designed in the sense that I've got this magic number 3 everywhere that I am going to mess up at some point. If I change it to a 4, I bet you I'm going to miss one of those locations. So we should probably improve that as well. 

01:03:00 Well, let me go ahead and just confirm that I didn't make things worse-- make scores. I did. What did I do wrong here? Error-- call to undeclared function get_int. STUDENT: Yeah, include cs50.h. DAVID J. MALAN: Yeah, I didn't include cs50.h That's why the compiler just doesn't know what a get_int even is. So that's an easy fix. Let me go ahead and type that in here. Clear my terminal, rerun make scores. OK, now we're back in business-- ./scores. Now I'll type them in when prompted by get_int. getting the math correctly. But I can do a little better, so let me hide my terminal window. Let's get rid of this magic number 3. How can I do this? Well, I could do something like this-- int and maybe capital N equals 3 for a number that's not changing. But actually, there's a technique. If you want to tell the computer, don't even let me change this number, what can I write on line 6 before int? STUDENT: Const. DAVID J. MALAN: Const-- we haven't used it much. But this is just a way of protecting you from yourself, 

01:04:00 or protecting your code from some dumb colleague who goes in and tries to change a number that they are not supposed to. So const int N equals 3 means this variable shall be forever the value 3. What can I then do with this? Well, I'm going to change the And down here, it's a step backwards. I don't want to do N just yet, but I can cast this to a float to make sure that 3 is treated as though it's 3.0. Now, I capitalized N just by convention. Generally, when you use constants, humans tend to capitals. Why? Because it just jumps out to the reader. Wait a minute, like, this is capitalized for some reason. That usually means it's meant to be a constant, just as a little visual heuristic. This is still imperfect, because I'm still assuming that n is always going to be 3. But one problem at a time. Let me open my terminal-- make scores ./scores 72, 73, 33. Code still seems to be behaving correctly, except for notice this time, we're seeing a bit of an artifact. 

01:05:06 Now suddenly, I lost a 1, 10, 100, So the rounding is a little different. But that's because fundamentally, when dealing with floats, they are going to be imprecise. They're maybe not very imprecise, but slightly imprecise. Thus far we were getting an additional 3 there, not a 2. That's just a side effect per last week's discussion. Well, let me go ahead and do this. Instead of typing this one out myself, let me go ahead and grab from the oven already cooked a program called scores version 5, which I wrote in advance, which now has everything. So this is a lot on the screen all at once, but let's focus on what's similar. I'm including cs50.h and stdio.h. I'm declaring a const. Notice, though, that I've put it at the top of my file instead inside of main. And that's OK. It is sometimes OK and a good idea to put your constants outside of functions, so that if I do want to change it somewhere, 

01:06:00 it's obvious where to change it. It's not buried in some function. It's at the very top of the file where it's more obvious to the reader. Notice now, I've introduced a function called average-- more on that in a moment, because the problem I still had, was even though I had I was still manually adding score0, score1, score2. What about scores 3, 4, Well, how am I solving this? Well, notice this. In main now, I'm giving myself access to N score. So whatever N is, make the array big enough. And this is a cool technique with arrays. If you don't know when you write the code what the size is, just use a variable. And the computer will give you an array of that many spots. The for loop is exactly the same here, exactly the same here. I'm just prompting the user again and again for each of their scores. The only thing I've changed now is fix the final problem. Instead of just printing out the average of score0 

01:07:01 plus score1 plus score2 divided by 3, I'm actually asking a helper function, so to speak-- another function that I wrote called average that takes two values. One is N because it's got to know how many values to average-- what's the denominator, and then the array itself. And this is the only new piece of syntax now with respect to arrays is how I'm passing this in. Let's focus on just the math for a moment. How do I calculate an average when I know don't in advance how many values there are, so I can't just do this plus this plus this all divided by 3? Well, let's create a variable called sum. Let's then iterate over the length of that array. Let's use some of last week's syntax to add to that sum the value at location i, location i, location i as i goes from 0 to 1 to 2 on up. And then lastly, how do you calculate the average? Well, whatever that sum is divided by the length of the array. Cast it again to a floating point value. So the only thing here is a recollection from grade school that, to calculate the average, you just add, add, add 

01:08:03 all of the numbers in the numerator, and divide once by the denominator. So I've used some C code with a variable and a for loop to do just that. The only weird thing I'll call out here is this. Notice how I wrote the average function. It's called average. It returns a float, which we haven't seen before. But it stands to reason, if we can return INTs and if we return nothing like void, I could probably return a float. And that's correct. This is the output of this function. That is why I can return a value. But this is weird. Not only does average take two arguments. One of those arguments as of today is now an array. So I could call these arguments anything I want-- a, b, x, y. But I'm calling them more usefully the length of the array, and then the name I want to give this array. But I could call it anything. I could call it numbers. But I called it array for the sake in class of making super-explicit what an array is. But this is the weirdness. When a function takes as input someone else's array, 

01:09:00 you don't have to know in advance what the size is. So you just say open bracket, close bracket, and leave it at that. But you need to make sure that caller, the function who created the array, also tells you with a second argument how big it is. This is not true in Python. This is not true in JavaScript and certain other languages that some of you might be familiar with. But in C, if you pass an array as input, the function doesn't have to know how big it is. But you have to tell it how big it is by giving it a second argument. And that's it for this use of square brackets. We've used it to create the array, to access or index into the array, and now to pass the array. So square brackets almost always are going to hint there's an array going on here. I suppose we should run this to be sure that I didn't screw it up. So make, let's do this. Copy .src/scores5. So we haven't shown you this yet, but if I have a file secretly called scores5.c, 

01:10:02 and I want to rename it to scores.c, I can use the cp command, for copy for short. It's going to prompt me to overwrite scores.c Yes. And so now, if I open what was always called ./scores, I now have exactly the same file as we walked through a moment ago. So let's run this now-- make scores ./scores 72, 73, 33. And we still get the same correct average. But now the code is arguably not only correct, it's better designed. Even though things escalated quickly, because to make this code better designed, I needed to generalize it to handle not 3, but ultimately, any number of exams or scores by changing the 3 to a 4 or a 5 or 100 or anything else. And heck, if we really want, we could ask the user, how many scores do you have already by calling get in one more time, and then avoid the constant itself. Whew! OK, that was a lot just to calculate a very bad score. 

01:11:02 Questions? Yes? STUDENT: What happens if I try to access a point in the array? DAVID J. MALAN: A really good question. What happens if you try to access a point in the array that hasn't been given a value yet? We will see that actually soon. You can go there, but you don't know what you're going to expect. So just to be a little dramatic, why don't we go ahead and have some delicious animal crackers? Take a 10-minute break. And when we come back, we'll start building on these examples. All right, now that we have this new tool in our toolkit of arrays, let's see how we can take it out for a spin and rethink, and also solve different types of problems, starting with a super simple message of "Hi," which is where we really began over the past couple of weeks too. So suppose I wrote some code in an actual program soon that just stores three chars. And I'll call them simply c1, c2, c3. Initialize them to H, I, exclamation point, which not coincidentally is exactly the numbers we've been playing with-- 

01:12:01 Recall from our so-called ASCII charts from weeks past. So what's going on with code like this? Well, let's go ahead and try it out. Let me open up a new file called-- how about hi.c? And in VS Code, I'm going to quickly do include stdio.h int main void. And then inside of main, let's give exactly those three lines-- so char, char C1 equals, quote unquote, "H." Char C2 equals, quote unquote, "I." Char C3 equals, quote unquote, exclamation point. And just to be clear, why am I using single quotes instead of double? STUDENT: It's a character, not a string. DAVID J. MALAN: So it's a character, not a string. So strings are double-quoted. Individual characters are single-quoted. All right, so with that said, let's actually just poke around these variables. So let me go ahead and use printf and print out three things, three placeholders-- %c%c%c backslash n. And let's plug in the value of each of those variables-- c1, c2, c3 just to see what's going on. 

01:13:00 Well, this one won't be all that enlightening. But if I do make hi, ./hi, I should see literally Hi! But I'm not printing it as a string. I'm printing it as char, char, char from left to right. All right, so can I maybe improve this a little bit? Well, let me go ahead and tinker like this. If I actually want to see the numbers that the computer is storing, let me first add some spaces here for clarity. Let me add some spaces here for clarity, and let me change the placeholders from c to i. Because it turns out that if characters are just numbers per our discussion of ASCII, and then more broadly Unicode, what's really stopping me from just telling the computer treat this sequence of bits not as a char anymore, but as the integer that it actually is? So we can use printf with %i instead to do exactly that. So let me rerun make hi, ./hi. And what should I see now when I hit Enter. STUDENT: [INAUDIBLE] 

01:14:01 DAVID J. MALAN: Probably 72, And indeed, that's all that's going on underneath the hood, so to speak, of these three characters. In fact, if we take a look at this code now in the context of the computer's memory, a char, recall, is one byte by definition. So we need three such bytes for three chars. So that might end up being H, I, exclamation point here. Or who knows? Maybe elsewhere in memory with those three variable names now in describing those three locations. Well, once I've got that in place, what's really going on underneath the hood? Well, obviously, it's actually storing 72, 73, 33. And if we really go down lower level to where we began week 0, technically what's inside of the computer's memory is these three patterns of zeros and ones. But again, who cares about these zeros and ones? But they are there. But it's easier to think about them as numbers, or in the context of actual words characters instead. So what is a string? Well, we introduced a string last week as being a sequence of characters. 

01:15:02 But it turns out that we actually really know more so now what a string is. So for instance, here is an example of declaring a string called s and setting it equal to the value of "Hi!" let's actually put this into some code. Let me go back over to VS Code in hi.c, and let me just tweak this code by really throwing away all of these lines. Let's do string s equals, quote unquote, in double quotes now, "Hi!" And then print out %s backslash n and print out s itself. And just so I have access to it-- more on this another time, let me proactively include cs50.h at this stage. So all I've done is exactly this line-- string s equals "Hi!" And let's just print it back out, just like hello world before it. Make Hi, ./hi, and indeed, I see H-I exclamation point. But what's going on now inside of the computer's memory. Well, just like the sequence of H-I exclamation point, what is a string? Well, a string is a sequence of characters-- yes, 

01:16:01 which means back to back to back contiguous in memory. So if this is the computer's memory, and I have created a string called "Hi!" It is indeed going to be called s. And it's going to have H-I exclamation point back to back to back in the computer's memory. Well, what's noteworthy here is that this looks awfully similar to stuff we've been doing thus far. Like, in fact, if a string is, yes, a sequence of characters, could we slap another name on what a string actually seems to be as of today? STUDENT: Array. DAVID J. MALAN: An array of characters. It's a sequence of values contiguous in memory. Well, that's pretty much equivalent to what I've been calling a string. So I bet we could think about "Hi!" as really being three locations called s, where this is really s bracket 0, s bracket 1, s bracket 2. And it's not that hard to even reveal this with a bit of C code. Let me go back to VS Code here. Let me leave line 6 alone. But let's go ahead and do this. 

01:17:03 Instead of printing out one placeholder %s, let's print out %c%c%c backslash n, comma-- and there's no c1, c2, c3 now. There's only s. So let's print out s bracket 0, s bracket 1, s bracket 2, close parenthesis, semicolon. Go down to my terminal window make hi, ./hi It's the same darn thing. So all of this time, as of last week, when we were playing with strings, we actually already were using arrays. We just didn't call them that. But a string is a sequence of characters. An array is a sequence of values. So really, a string is just a more precise type of array specifically containing characters. Well, what's really going on inside the computer's memory, then, is indeed this. You've just got one variable called s, but it's got indeed three locations. But the difference here between strings now and what we were playing with previously, scores, where we had one, two, three scores and we had to keep track of the number of scores with a variable-- like n, or by literally typing 3 into my code. 

01:18:00 If I only have one variable in this program s, and yet it's somehow working, how does the computer know where s starts and where s ends. Like when I print out s as a placeholder, why is printf not just printing out everything that's in the computer's memory? How could we solve this. Well, at the end of the day, there's no magic. All we have is this canvas of zeros and ones. And if you want to keep track of something, you have to spend some of these bits. You have to use some of these bytes. So it turns out that the way a computer keeps track of where the end of a string is, even if that string is three characters, the length of the string-- the length of the array really that's storing the string, is technically 4. It's 1 plus whatever the actual length of the phrase is. So if s begins here, it's obvious to our human eye that s ends here. But how does the computer know that? It spends one extra byte always for strings, unbeknownst to you, 

01:19:01 and it fills them with all zeros. And so technically, s is, yes, length 3-- H-I exclamation point. But it uses 4 bytes because of this special value-- this sentinel value, this terminating character that indicates, hey, the string stops there. Now, this invites the question, well, how do you represent all zeros? More on that another time. But for now, we're just using all 0 bits as a special signal that string stops here. Now let's stop talking about bits all the time. This is really just the number 0. So technically, whatever the string is, the last byte in a string will always be 0. This, though, is a little not ambiguous. Like is this, like, 0 bits? Or is this like the number 0 on my keyboard? Like, do I want to see the 0? So typically, the convention is to put a backslash in front of the 0 to make it clear that this is a special character. This is a special character like backslash n, like some of the other characters we've seen. That just indicates the string ends here. It's the same thing as all zeros, but it avoids that visual ambiguity. 

01:20:01 So we can actually see this. If this is what's actually going on underneath the hood, we can actually see the fact that this is there. Let me go back to VS Code here, and let's just get a little curious. Instead of printing out three of these things, let's go ahead and do this. Let's print out %i %i %i, as before. And this is no different from earlier make hi, ./hi There are those three numbers. But let's get curious and print out one more placeholder-- %i, and print out s bracket 3, which I'm assuming will exist because, as indicated, a string always gives you one extra byte for that special terminating character-- make hi, ./hi. Voila, there is the zero. Unbeknownst to us last week, and unbeknownst to us before break, it's always been there with any string underneath the hood. The variable keeps track of where the string begins. But zeros indicate where the string ends. 

01:21:06 Questions on this technique or this implementation detail? Yes. STUDENT: What would happen if we went to the next? DAVID J. MALAN: What would happen if you went to the next? A good question. And honestly, there's nothing really stopping us. So let's try going one more location, so s bracket 4. Let me go ahead and do make hi, ./hi. If we do one more, %i s bracket So these are actually unpredictable, and are actually representative of those same kinds of garbage values that I alluded to earlier that don't really belong to us. Like, I really shouldn't be poking around places where I haven't asked for the computer to give me memory. But odds are, those are evidence of other values in this program, or maybe remnants of the memory having been used prior. But the only one we can trust will exist is 1 greater than the string's actual length. Really good question. 

01:22:01 All right, so what is this thing called. Well, conventionally, this thing is called null. So nul-- single L. We'll see another version of null that's spelled a little differently. And we've actually seen it before, even though we waved our hands at it. Here is the ASCII chart from week 0, in fact. And we focused on H-I exclamation point. But here's the first column. And notice, location has always been what humans call N-U-L, or nul, which is just a special sentinel character, a terminating character, that says, string ends there. All right, well, what if we have multiple strings, for instance, like one string s called hi with a value of "HI!" and one string t with a value of "BYE!" Let's actually play a little with that and see where things end up in memory. So let me go back to VS Code. Let me get rid of this long printf. And let me give myself another one, string t equals "BYE!" And I'll print out both of these-- printf, quote unquote, %s backslash n, 

01:23:03 s, and then printf s backslash n, t semicolon. And now make hi, ./hi And we'll see, as you would expect, just "HI!" and "BYE!" on the screen. What's going on inside of the computer's memory, though? Well odds are we're going to see two chunks of memory in use-- s and t, respectively. Maybe s ends up here, which is the whole thing here. Technically, this is s bracket 0, 1, 2, 3. But who really cares at this point? It's just a string called s storing this value. And though this is up to the computer and the context when we write the code, odds are "BYE!" will end up right next to it in memory. It's too big to fit on the screen. So there's still another character here, but it's indeed here. So even though you and I only ever write "HI!" or "BYE!" point, the backslash ends up being added automatically for free. And fun fact-- this is what the double quotes are implying. When you use double quotes, that's a visual cue to the language, 

01:24:00 oh, this is a string. Let me terminate it with backslash 0. You do not want a backslash because single would mean one character. So single quotes distinguish that for the computer as well. All right, so now that we know this, we can actually solve other problems as well. In fact, let me go ahead and do this. Let me go ahead and syntactically play around here. So if I know that I have two variables here-- let me draw some inspiration from the scores example. If I have a whole bunch of strings, I probably don't want to call it, like, s, t, u, v and so forth. Let's just give myself one variable of type string called words. Let's give me two of them for the sake of discussion. And then let's have the first word-- so words bracket 0 equal, quote unquote, "HI!" Let's have the second word-- words bracket 1 equal, quote unquote, "BYE!" So just like I did with the scores, let's just consolidate all of these 

01:25:02 arbitrary variable names into just one that's a little more descriptive, like "scores," or in this case, "words." How do I now print these. Well, instead of printing s and t, I can print words bracket 0, and I can print words bracket 1. And if I go down to my terminal make hi again, ./hi, it still says the exact same thing. But here's where things get interesting. You can compose these ideas in different ways. This is not something that's useful, but it does speak to the fact that there's no magic. Now that you have these square bracket notation, you can start poking around wherever you want, for better or for worse. So, for instance, suppose I want to print out the three-letter word high. Well, I could change %s to be %c%c%c for "HI!" But wait a minute. How do I print out characters? Well, this is a neat feature. If words is the array, and words bracket well, what is a string? 

01:26:01 It's just an array itself. So if you want to go into the first character of the first word, you can actually do this syntax. Use brackets twice. The first set of brackets says what word do you want. The second set of brackets says what character do you want, because again, this is an array of strings, a.k.a., an array of arrays. So let's do words bracket 0 bracket 1, words 0 bracket 2. And then down here, I know this is a four-letter word. So again, this doesn't really solve a problem. It just demonstrates what's going on. Here's a four-letter word. Let's change this to words bracket 1 location 0, words bracket 1 location 1, words bracket 1 location 2, words bracket 1 location 3. So again, not something that's really compelling to use. But it does demonstrate that there's no magic. All that's happening is %s is saying go print a bunch of characters until you 

01:27:00 see the backslash 0 %C is letting me manipulate these things manually. So make hi ./hi, exact same thing as before, by just building on the assumption that these strings are really just arrays. OK, so how do we actually leverage this idea and figure out dynamically how long these strings are? Because I bet any time we want to start iterating over the length of text, maybe to determine the reading level of a chunk of text, we're going to have to be able to read the thing from left to right, and stop when the sentence or the paragraph actually ends. So how might we do this? Well, let me actually go back over to VS Code. Let's create a new file called length, and let's write a program that figures out the length of a string for us. So length.c shall be the name of this file. Let's go ahead and include cs50.h at the top. Let's include stdio.h at the top, int main void. And then inside of main, let's do this. Let's ask the user for their name-- string name equals get_string. And then prompt them for their name with name colon, quote unquote. 

01:28:00 Then let's go ahead and figure out the length of this string. So how can I figure out the length? Well, bunches of ways, but loops come to mind if I want to iterate from left to right. So let me propose that we first initialize any variable to 0. I'll call it n for number, but I could call it length or count or whatever. Then let's do a for loop. Or no, let's do let's do a while loop actually, like this-- while the name array at location n does not equal the nul character. Go ahead and increment n. And then at the very bottom here, let's just print it out-- printf of %i backslash n. All right, so there's a bunch going on here. But it's a relatively simple idea. What do we have? So we're prompting the user on line 6 for their name. Pretty straightforward per last week. Line 8, we're just saying start a variable at 0. So all fingers are down or the stress ball bowl is empty. This is the only line that's a little weird to see for the first time, 

01:29:00 but it's just doing this. Line 9 is saying while it is the case that the name string at this location does not equal the null character, increment n. So it's like using a finger and pointing at the string from left to right, asking itself is this null, is this null, is this null? And if it is not null, then it's going to increment n. So if the first letter is h at location 0, well, h is not equal to the null character. So n gets incremented once. So the expression "HI!" has at least a length of 1. i does not equal the null character, so n is going to get incremented again. The length is now at least 2. Exclamation point does not equal nul character n is now three. But what comes after H-I exclamation point? The null character, so the character at location 3-- name bracket 3, which is the fourth total location, because we started counting at 0, is the null character. This does not get incremented anymore. 

01:30:00 I've only got three fingers still held up. We're going to see the value 3. So this is a very mechanical, clunky, but very correct way of figuring out dynamically the length of a string by just looking, looking, looking, looking, and figuring out where it is. How does printf then know when to stop printing characters on the screen? When you just hand it the name of a variable, it is literally doing the same thing. It is looking at your string left to right and checking, is this null, is this null, is this null? And as soon as it is null, it stops printing words on the screen. It's been doing this for us since last week. So if I open my terminal window now, do make length, Enter ./length. Type in a name like David, Enter. And I do get back the number including the null character. I'm stopping once I hit it. And therefore, I get 5. Syntax is a lot, but any questions on this here? 

01:31:01 All right, well let's make one tweak, and then make it even simpler. So in my code here, wouldn't it be nice if I could just call a function that figures this out for me? So for instance, suppose I want to get the length of the name. Well, let's just give myself a variable called int length, set it equal to the return value of a magical function that doesn't yet exist, called string_length, and pass in the name to that function. And then go ahead and print out with printf exactly that length with %i, length. So wouldn't it be nice if a string length function exists? Well, it's not that hard to create one. If I have a function called string_length that returns the length of a string, I want this function to return an int, so that's its output or return type. The name is going to be, of course, string_length. What's the input to this function going to be? Well, it expects a string as input and I can call it anything. So I'll keep it simple. I'll call it s for string. And then inside of this function, honestly, I think I can copy-paste that code from before. I just need to change name to s. 

01:32:03 And instead of printing n, what do I want to do at the very last line here? STUDENT: Return s. DAVID J. MALAN: Yeah, so return s. Hand it back to whoever is using this function, so that it gets passed from right to left, stored in this variable, and then printed. There's one thing I have to do. Again, it's silly, but copy-paste the prototype at the top of the file, so that the compiler knows about it. But I think now I've created my own string_length function that can just figure this out for me. And as before, with Scratch, out of sight, out of mind, I never again need to implement a string_length function if I've already done it once. But let's not be dramatic. Let's just undelete all of these blank lines. Let's now compile this code. So make length again. Oh, I messed up. What did-- ah, I don't want to return s. I screwed up. I want to return n, which is the number. s is the string. So that's what it's saying here. And we'll come back to, in a couple of weeks what these words, like "pointer" and "conversion" mean. Make length. 

01:33:00 There we go-- ./length D-A-V-I-D. I still get 5. Well, wouldn't it be nice if someone had solved this problem for us already? And it turns out there is. So recall from last week, there are some std libraries that come with C-- not just CS50, not just std IO, not just the math library. There's actually a string library that's got a bunch of string related functions in it that are super-helpful. In fact, in the manual pages, or man pages, for the string library at a URL like this, which is CS50's version, you'll see exactly an option called the strlen function-- S-T-R-L-E-N for short. There's the documentation on the screen and sure enough, there exists a function called strlen that does exactly this. So in fact, I can actually wonderfully enough, get rid of most of the code I just wrote by deleting that, as well as its prototype. I do need to include one more header file, so string.h. But instead of calling string length, I can call strlen. And now my program is done. 

01:34:00 So here, this is evidence of why we stand on the shoulders of programmers before us. Someone else already solved this problem. It's intellectually interesting to understand how they solved it. But why bother reinventing the wheel again and again when you can use a library function to do exactly that? So this version of the code, I think, make length, ./length D-A-V-I-D, Enter. Still works, but it's, like, three lines of actual code now, instead of a dozen or more that it was for a moment. All right, questions on any of this? Questions in the back? All right, so let's do a different sort of problem, but still borrow code that others have written before. So besides the strlen function in the string library, there's another oddly named library called the ctype library, which is related to ctypes, so converting from one thing to another or detecting thing. So in the ctype library whose documentation is here, you'll actually see a whole bunch of functions. 

01:35:00 So if I go here, you'll see things like isalnum. It checks whether a character is alphanumeric. Isalpha-- check whether a character is alphabetical. Isdigit-- check whether a character is a digit. Isspace-- check whether a character is whitespace, and so forth. Toupper, tolower-- toconvert a char to lowercase, to uppercase. There's so many functions that someone else wrote that actually seem, at a glance, pretty useful. But how might those kinds of things be implemented. Well, here's that same ASCII chart as before. And notice this kind of curiosity. Here are the start of the uppercase letters. Here are the start of the lowercase letters. And just take a look at A. We know from week 0 that A is 65. And apparently, lowercase a is 97. Quick mental math-- how far apart are those numbers? STUDENT: 32. DAVID J. MALAN: That's right 32. So they're 32 apart. But notice the pattern. How far apart are 98 and They're all 32 apart. And this is actually wonderful for the real geeks in the room. 

01:36:04 You can just change one bit out of eight and turn a number from uppercase to lowercase and back. But for the rest of us, notice that 32 is the constant here that explains how you get from uppercase to lowercase and back. Well, we could leverage this and implement our own function that somehow plays around with the cases of letters. So in fact, let me go back to VS Code here. And let's create a new program this time called string.c, just to play around. And in string.c, I'm going to go ahead and include my same header file-- so cs50 and in stdio.h. And I'm going to use string.h. And then in int main void, I'm going to go ahead and do this. Let's prompt the user for a string s by using get_string, and just ask them for input, whatever that input actually is. Let me just preemptively say printf, quote unquote, "Output." 

01:37:02 And let me just go ahead and close quote, close parenthesis, semicolon. And now what I want to do is convert the user's input. Actually, for now let's do it simple. Let's just print the exact same thing that the human types in. So we're going to keep it simple, just to make sure we have the framework for a program good to go. So for int i equals 0. i is less than strlen, s. Let's go ahead and do i++. And then inside of here, let's go ahead and just print out that character. So print out %c backslash. Let's no backslash n. %c, quote unquote, "s bracket i." So I think this code here will print out the i-th character of s from 0 to 1 to 2 for however long it actually is. And at the very end of this program, let's go ahead and print out just a single backslash n. So this doesn't do anything that interesting yet. But let me go ahead now and run make string. 

01:38:01 I messed up because I'm typing too fast. This semicolon goes on the outside. Let me do make string, ./strong. And I'll type in D-A-V-I-D. And I get the exact same output, so not all that interesting. But before we start playing around with uppercase and lowercase, let's actually clean this up slightly. This program is correct if my goal in life is to just print the exact same thing as output as I was provided with input. But it's arguably not well designed yet for a very subtle reason, even though I am very cleverly practicing what I preached a moment ago using the strlen function from the string library. Now, this is super-subtle. But on line 9, recall how a for loop works. Like, you initialize I to 0. Then you check the condition, then you do something, then you increment, then you check the condition. You do something, you increment. Then you check the condition. You do something and you increment. What might rub you the wrong way design-wise about the story 

01:39:04 I just told, given that strlen is involved in that decision-making. Yeah. STUDENT: So it's the same every time but you're calculating it again. DAVID J. MALAN: Perfect, really good intuition. Like, the length of s is not changing. So why am I wasting everyone's time by calling the strlen function again and again and again? i is changing, so that part is correct. But why am I calling this function? And notice, because I have written strlen parenthesis s, it will call the function again and again and again. It's not going to very intelligent and be like, oh, well it hasn't changed necessarily. Let me just do that for you-- unless you have a compiler that has a feature like that enabled. But at a glance, this just seems very inefficient. So how can I improve this? Well, I can do this in a couple of different ways. Let me go back to the code here. Let me grab strlen of s, and let me do this-- like, int length equals strlen of s. And then I could do this. So this is arguably marginally better because I'm calling strlen once, storing the return value in a variable, and then using it again and again. 

01:40:01 Now, that's fine, that's correct, that is better-designed. But this is such a common paradigm, there's another way to do this. Instead of doing strlen of s inside of the condition, you can instead do this. You can declare a second variable like length. Or heck, I'll keep it simple-- n, set it equal to the string length of s. And then all within for loop, you can do the comparison by having initialized not one, but two variables at a time, so long as those variables are both the same type. Now I'm declaring two integers at once. But the first part here, before the first semicolon, is only executed once, because that's the initialization. So again, subtle, but it speaks to efficiency because I'm not calling the darn function again and again when the string s is never actually changing in length. So it's subtle, but arguably better designed. Now, with that said, can we go and actually use this knowledge of the ASCII chart? Can we use this technique of optimizing with strlen 

01:41:02 to combine things, and start changing things to and from uppercase and lowercase? Well, let's try this. Let me go ahead and open up a new file called uppercase.c. And in uppercase.c, let's go ahead and use those same files include cs50.h, include stdio.h, include string.h, and now and int main void. Inside of main, let's go ahead and do the same kinds of things, but a little bit differently. String s equals get_string. And let's ask the user for input. We'll call it before. So what's the string before we do anything to it? Now let's go ahead and proactively print out the word "after," just so that we can compare it. And I'm going to very cleverly use two spaces, just because before is longer than after. But I want them to line up perfectly above each other. So I'm adding two spaces there, just for aesthetics. Now let's do this. Let's iterate over the characters of s and check if it is lowercase. Let's turn it to uppercase. Otherwise, let's not touch it at all. 

01:42:06 So how can I express that-- for int i is i++ and then in here. But wait a minute. Let me learn from what I just said. Let me avoid calling strlen again and again and again. Let's just call it n equals strlen of s, and then compare i against n. N is not changing. I is changing. So that condition is now handling the logic I want. Inside of the for loop now, I have to ask a question. Is the current character, the i-th character of s lowercase? If so, change it to uppercase. Now, that's a mouthful. But I can use last week's building blocks and this week's understanding of arrays to express exactly that. So if it is the case that s bracket i-- so the i-th character in s is greater than or equal to lowercase. And s bracket i is less than or equal to quote unquote, "z." 

01:43:04 then I want to go ahead and change s bracket i to uppercase. I don't know how yet, so I'm just putting a comment, putting in pseudocode. Else if it's not lowercase, then just print s bracket i. Now, let me go back to our little cheat sheet here. So we only have the beginnings of it highlighted at the moment. But we know that the difference here is 32. But more interestingly we know that lowercase starts at 97. And if I look in the shaded part, it goes to 122. So technically, I could actually do this arithmetically with numbers. And I could go in here and say, is greater than or equal to 97 and less than or equal to 122. That's fine. But honestly, because we know from the previous example, a char is just an int, an int is just a char, and you can format them however you want, you can also manipulate them mathematically however you want. So it's arguably better design and clearer to you, clearer to the TF, clearer to the reader, the colleague, that, oh, you're comparing the ASCII values, not some random number 

01:44:00 that I don't remember from class years ago. So greater than or equal to lowercase a, less than or equal to lowercase z expresses exactly what we want. So I'm going to pluck off the easy one first. How do I just print s? Well, I do printf %c, s bracket i. That means just spit it out unchanged. It's not lowercase so there's no change to it. Let's just spit it out, whether it's already uppercase, or maybe it's punctuation or a number-- whatever. Now, this part is the last part. How do I go ahead and change a character from lowercase to uppercase. Well, I know minimally, I'm going to want to print some character. So let's just proactively do %c as my placeholder. I kind of want to print s bracket i, but I want to change s bracket i to uppercase. What could I do mathematically to a lowercase letter to make it uppercase according to the cheat sheet? STUDENT: [INAUDIBLE] DAVID J. MALAN: Yeah, just subtract 32. So subtract 32 here. 

01:45:00 And now let's add one final flourish. Let's just add a backslash n, just so the cursor finally, at the very end of all this, is at the bottom of the prompt. Let me go ahead and open my terminal-- make uppercase enter. OK, I did screw up. I did it again. I'm going too fast. Semicolon on line 14. Let me clear my terminal, rerun make uppercase-- good, ./uppercase, David with one capital letter, the rest lowercase, Enter. And voila, now we've uppercased everything, just by understanding the underlying implementation details of what's going on. Honestly, if you don't remember Like, whatever the distance is between capital and lowercase, that's actually what I want to subtract. Or I could do b or c or z or whatever. better to do a minus A, because then you know it's going to be dynamic between the two, even if you forgot from class what the actual difference of 32 is. But this is a little silly that I'm doing all of this work 

01:46:02 just to change things to uppercase and check for lowercase. How can I make this a little better? Well, turns out that ctype library is actually our friend. Here, let me go back into this code here. Let me include my ctype library. And it's not necessary, but I tend to alphabetise things, just because then at a glance, I can see what header files am I actually using. And I'll know If something is missing. Let me go into my code here. And you know what? Instead of doing all of this, it turns out that in the ctype library there was a function called toupper. And if I read the documentation of toupper, it essentially takes as input per its prototype in our own documentation down here a char-- call it c And it returns the uppercase version thereof. It technically returns an integer, but who cares? We know that this is functionally equivalent to the same thing. So let me go back to my code. And honestly, because I have now included ctype.h at the top, 

01:47:01 I can just say toupper of s bracket i. Let me open my terminal. Let me rerun make uppercase, ./uppercase David. And now it's still the same. But even this is silly, because if I read the documentation for the toupper function more clearly, it actually says that it will handle this conditional decision of whether the thing is already uppercase or not, or whether it's lowercase or not. So I can actually change all of this messiness into just a single line of code in my loop. Printf, quote unquote, "%c" comma toupper s bracket i. Now semicolon at the end. Let me reopen my terminal window-- make uppercase, ./uppercase David. Yet again, that too works. So again, libraries are your friend, or designing a function once, and then somehow reusing it-- which is another technique we'll introduce over time, 

01:48:00 will save you time in the long run. Once you have invented one wheel, you do not need another for the same problem, so to speak. Whew, OK, any questions on this exercise here-- the goal of which, to be clear, was really to paint the picture of, one, how you can manipulate all of these lower level details now by understanding the ASCII chart from week 0, and now arrays from week 2, and solve all of these problems by just using someone else's code already in the form of these libraries. OK, so let's come full circle to where we began, so that we also touch ultimately on a bit of that cryptography and the art of scrambling information to better prepare you for actually solving some of these problems with your own code. This notion of command line arguments that I mentioned earlier, command line arguments are, again, just words you can type at the command line to influence the behavior of a program. So make hello-- hello is the command line argument. Clang hello.c-- Hello.c is the command line argument. 

01:49:02 Hello, -o hello, hello.c -o, and hello and hello.c are the command line arguments, plural. So how do we actually write code that accesses words at the command line? Because thus far, we have not written any code or any programs that can do that. But Make can and Clang can, and other programs can as well. So how do we make our own? Well, up until now this has been how we've implemented main. We've been asking you to take on faith that it returns an int always, even though that hasn't been useful for anything yet. And we've always specified that main takes no input, so just write void. I've been literally typing this for every program, as did you presumably, for problem set 1. Well, it turns out that you can actually change the void in main to be something else. If you want your program to accept command line arguments, words at the prompt when you run your own code. And you can change this void-- it's a bit of a mouthful, to be this whole thing instead. Now, it's long at a glance. But what is it? It's two arguments. One is an int. One is a string-- 

01:50:00 technically, an array of strings. So this is why we introduced that syntax earlier. When you have an array being passed into a function, you just use square brackets and no number inside. So what this implies is that main can, if you want, take an integer and an array of strings. Now, technically you can call these things anything you want-- a, b, x, y. The convention, though, is to call it argc and argv, where argc means argument count, how many command line arguments have been provided. And argv stands for argument vector. A vector is often another word for an array, although there are subtle differences. But in this context, it just means array. Argument vector is an array of all of the words that the human typed at the command line. So how can we use this technique? Well, let's go ahead and do something like this. Let me go back into VS Code. And let's go ahead and create a program called greet.c. So in greet.c, let's write a program that just greets the user. But instead of using get_string, let's just 

01:51:01 ask them for their name at the command line, so they can type it all at once, hit Enter, and be done with it. They don't have to wait and be prompted, and then hit Enter. So let's go ahead and include cs50.h. Let's go ahead and include stdio.h, int main not void. Let's do void first, actually-- void, just to compare and contrast what we did last week. What we did last week would have been literally answer equals get_string. Prompt the user for "What's your name?" space semicolon, and then printf, quote unquote, "hello, placeholder," backslash n, answer. So this is week 1 stuff now, and we saw this same snippet at the start of today-- make greet, ./greet. I am prompted for David. And now I am greeted, "Hello David." So that's the old way of doing it. What is now the new way using this prototype for main instead using the signature, which is essentially synonymous, 

01:52:03 which means now what if main takes two inputs and still returns one output? Let me go ahead and, in my second incarnation here, let's tweak this as follows. Let's get rid of all of this. Let's change the void to be int argc, string argv open bracket, close bracket to make clear it's an array, not a single string. It's an array of strings. And then inside of this function, let's do this-- printf, quote unquote, "hello, placeholder" backslash n, like always. But what do I want to print? Well if argv is an array, let me do argv bracket 0 maybe, semicolon, and that's it. Let me now open my terminal window. Let me again do make greet, ./greet. And this is going to look a little weird, but here we go-- ./greet David. You'd think this would now say, "Hello, David." But it says hello ./greet. All right, so wrong, given my intent. 

01:53:02 But what can you infer about what is stored in argv0, apparently by convention, by having just poked around here? STUDENT: [INAUDIBLE] DAVID J. MALAN: The name of the program, which hasn't been useful yet. But if you ever want to have documentation maybe built into your program, or maybe like an explanation of how to use it, it might be nice to reflexively know what is my name. And you can actually figure out the program's name dynamically, even if the user renames the file by using mv or right clicking or Control clicking on it, you can figure out what your name is in argv bracket 0. Well, where is the actual name that was typed in? Argv 1 is where the actual words begin that the human, like me, typed in. So let's recompile this. Let's do make greet again, ./greet David. And now I think I'll get a proper "Hello, David." I'm not using get_string, I'm not prompting the user. I'm doing it all in one breath. Unfortunately, if in the current moment I forget to provide a name-- let's 

01:54:00 just run greet enter, so nul. And this is not N-U-L. This is a different type of null-- N-U-L-L. This just means no value. So this is not very pretty. Maybe we can defend against this. And we can. Let me go ahead and close my terminal window. Let me temporarily get rid of this line of code. And let's conditionally print that greeting out. So if the argument count equals equals 2, then you know that there's the name of the program, which is always going to be there no matter what, automatically for free. And another word is there, like the name of the human typing the program. Then let's go ahead and, OK, let's print out "hello so-and-so." else if the user has not provided their name or they provided too many words, let's just go ahead and give them a default value like "hello, world" semicolon. Let me open my terminal window. Clear the terminal. Make greet again, ./greet David. It still works as before, because the number of arguments in argv is two-- the name of the program and whatever I typed in. 

01:55:00 But what if I try to be a little more formal? Greet David Malan, Enter. It just ignores that, because now the argument count is presumably three. And we didn't handle that, so I can't even greet people with last names. But that's fine. Similarly, if I just do ./greet and no name, that's also not two. So we again get the default value. But at least now there's no way this code is going to print out null. Weirdly, because I'm at least handling and checking how many characters there actually is. You can do other things with this too now. If I were to iterate over all of the words typed in, I could do this-- for int i is 0, i less than argc, i++ plus. So a relatively simple for loop. I can print out %s comma n, and then argv bracket i. So what am I doing here? Well, let's just try. I did that fast. But let's do make greet, ./greet David Malan. What am I going to see on the screen? Program name, my name, my last name. If I type in more words-- so maybe I do David middle initial J Malan, I just get one per line. 

01:56:02 So again, there's really nothing intellectually that interesting going on here. We just have a new integer, conventionally called argc, that tells us how many arguments there are. There is a new array called argv conventionally that's just an array of words that were typed in. So we can use last week's techniques with for loops, which are the exact same idea of loops from week 0, to just iterate over these things. So again, the syntax is new. It's going to be hard to remember it. Even I screwed up multiple times. But it's just going to come with practice. What's important is to understand the ideas underlying this and why these things work, not where the quotes and square brackets must be, because that will come indeed with practice. All right, so this is actually a fun way to demonstrate this. This is not educationally redeeming, but it's fun to show. Let me actually maximize my terminal window. It turns out that there's a lot of programs that come with systems like the operating system we're using called Linux, which is, again, the operating system running in the cloud underneath the hood of VS Code in your terminal window. ASCII art, which is a phrase I've tossed out there a couple of times, 

01:57:00 is like using the characters on your keyboard to depict things-- people, places, things, animals, or the like. Well, we can actually use a fun program called cowsay, which again, is really just for fun. But it does take command line arguments. And just for fun, I thought I'd share these. So if I want to go ahead and run cowsay-- let me do cowsay moo, Enter. And apparently, this program's purpose in life is to print a cow using ASCII art, and then put the word you type as the command line argument in there. If I change the word to be longer, like "moo," Enter, the ASCII art adapts. So someone spent like a bunch of hours to figure out how to format this dynamically to make things look nice. They also added some other features whereby with additional command line arguments, it doesn't just have to be a cow saying things. It can be, like, a duck. So the program is still called cowsay. But if you change the mode to be that of duck, and then say something like quack, you'll see three command line arguments now. And thus, when I hit Enter, now we have a cute little duck quacking. 

01:58:04 And perhaps especially fun is this-- cowsay -f dragon, like RAWR, Enter, and you get this crazy thing that took someone way too long to create. So again, there's nothing educationally redeeming here-- other than, hey kids, here's an example of command line arguments just to do silly things like this. It's a very common technique to more efficiently provide inputs to programs. So there's only one last thing to distill about main, which we've been asking you since last week to take on faith is, why does main return an int, even though we've not been doing anything with that? We didn't even know what the return values were initially. Well, it turns out that programs can have exit statuses. And we've not seen these visually yet. But even though we've seen. programs with side effects printing out "moo" or "quack" or "rawr" on the screen, technically, programs can also return secretly numbers. And those numbers are useful, usually to the programmers or to the computer, to signal more methodically whether something succeeded or failed. So case in point, if you've been using Zoom sometimes, when things are wrong, 

01:59:03 you might see weird Zoom error messages like this-- like an error code, 1132. That means nothing to the layperson. But odds are there's one or more employees at Zoom that, oh, shoot, they're seeing error code 1132. That is because we wrote code that returns this value in certain situations that indicate failure. This is a little different. But more of us are probably familiar with other numbers in the real world, like 404, whereby you go to a web page where the URL is wrong, the file has been deleted, you're in the wrong place. computer, indicates what has gone wrong, because some human decided 404 shall mean "file not found," for instance. So it's a little different from C code, but same idea. Numbers are used to standardize what can go wrong in programs. So if we look back at C, here is the way we define C main most recently. And we're now taking command line arguments. It turns out, though, that as before, main still and should always 

02:00:01 be returning an integer, even though we've done nothing with it, even if you don't have command line arguments. So in fact, we can take a step backwards there and consider exactly what this int does for us. Let me go back to VS Code, shrink down my terminal, and close our old example. Let's make one final program here called status.c because these integers are called status codes, for instance. Let's do this-- include cs50.h, include stdio.h int main-- and I'll stick with void, because we're sort of done with command line arguments for now. No we're not. We will do int main, then int argc, string argv with square brackets. And now let's actually use exit statuses to indicate that something went wrong, as opposed to just printing something on the screen. So I'm going to do this. 

02:01:00 If argc does not equal 2-- so I'm inverting the logic now, instead of equaling 2. If it does not equal 2, let's go ahead and tell the user Yes, missing command line argument backslash n. But so that the computer knows that something went wrong too, let's also return any number other than 0 within a certain range. So it turns out that 1 is a good place to start. Otherwise, if all went well and I can say in fact "Hello, placeholder," and then plug in argv bracket, same as before, let's explicitly indicate to the computer that all is well and successful and return 0. And even though this feels a little backwards-- like, usually one is true or yes, and 0 is false or no, turns out that 0 means success by convention. And any positive number, and sometimes negative numbers, means failure. Why is this? Well, if everything's successful, it's either successful or not. But there are dozens, hundreds, thousands of things, as you know, that can go wrong in computer systems. 

02:02:01 That's why we're using every number except 0 to describe erroneous situations. So I'm going to keep it simple, and use 1 and 0. I could use 1132 to be like Zoom. I could use 404 to be like a browser. But we'll keep it simple because I want to indicate failure or success, respectively. Unfortunately, you don't see this by default. If I do make status, Enter ./status, and then I will not provide a command line argument. I'm just going to go ahead and hit Enter. And I'm told missing command line argument. But I don't see a number 1. Similarly, if I run ./status, and I type in David, I see "Hello, David," but I don't see a status of 0. But there is a way at your keyboard to see what the status code is. And we, CS50 will use for automatic grading, for instance, we will look at the status code with which your program executes to determine, oh, was this successful or not. In the real world, when you're automating tests to make sure the industry code works, you might secretly check, is it a 0, 

02:03:01 is it a 1, Is it 1132, is it 404? These status codes are very useful for automation, even though, practically speaking, for you and me, they won't be as useful day to day. But you can type this esoteric command-- echo $?, and see what the exit status was of the most recent command that you ran. So, for instance, if I go into my terminal-- and again, let's just rerun make status to recompile it, ./status. And let's not provide a command line argument. Enter. I see the error. But if I now type this command, echo $?, Enter, I should see 1 because that is what I returned. If, by contrast-- let's clear this, I rerun ./status David, Enter, I see, "Hello, David." If I echo $? again, I now see 0. And just to emphasize the Zoom idea, if I do 1132, that's actually too big to be used here, that would show me 1132. 

02:04:01 But really it should be a smaller number in the context of these programs. But that indeed is what's going on underneath the hood. So we will very often in programs-- and problem sets prescribe that what you should have main return this number or this other number in certain cases so that, one, we're sort of doing things the conventional way. And two, we can also automatically detect exactly what has happened. All right, so let's come full circle to the last of the real-world domains, namely cryptography. And even though the way we encrypted This is CS50 earlier, it's pretty simple. We just changed every letter by one position. We now, all these minutes later, have the ability to analyze text. If a human types in something with get_string, you now have the tools to iterate from left and right to infer what's the reading level of this person, how do I convert this ciphertext to plain text, so to speak, or vice versa? We have the ability now to manipulate text already now in week 2. So how might this be useful? Well, encryption is the process of scrambling information, but in a reversible way. 

02:05:01 It's useless if you just scramble it and can't get the original back. So encryption is meant to be reversible. So here is the mental model you might have, whereby your inputs and outputs as always become plaintext, which is the original message in English, or whatever human language. The ciphertext is the scrambled version thereof. What's in the middle? The black box this week is always an algorithm, implemented perhaps in code. But a cipher is the type of function that enciphers information from plaintext to ciphertext. So it's just some terms of art here. But the catch with the cipher is that it must rely on a secret. And so there's a secret value, generally known as a key, that is provided to ciphers as a second input. After all, if all of us were using the exact same cipher in the exact same way, we could all decipher or decrypt each other's messages if it all works the same way. But not if we all choose a secret key, like a big random number that only I and the recipient. Then you guys can use the exact same algorithm. 

02:06:01 But without my key, you're going to be trying all day long to figure out what my key was-- at least so long as we pick a big random enough value. So how does that work? Given the plaintext, given a key, we can encipher the information to spit out that ciphertext. So for instance, if the input plaintext is "Hi!" and the key for the sake of discussion is super simple and 1, what can we do? Well, the output would be IJ!, if you are using an encryption algorithm known as the Caesar cipher. So back in the day, when the whole world was not really familiar with encryption algorithms yet-- because we're talking hundreds of years ago, they didn't have to be that sophisticated, because if no one else was thinking to do this, you might as well just add 1 to all of your letters, or something like that. So generally, it's believed that Caesar was among those who used rotational ciphers like this, whereby A becomes B, B becomes C. Or maybe you use bigger numbers, and rotate more than one place. 

02:07:00 It's pretty secure if you're the only one on the planet doing it at that time. Meanwhile, 1 plus "HI!" would give us IJ! because H plus 1 gives us I, and I plus numbers, punctuation just gets passed through unchanged, which is why I leaked the number 50 before, even though "this is CSS" was properly encrypted. Meanwhile, if we want to make things a little more sophisticated, we could use 13. And in fact, a special case of the Caesar cipher with an input of 13 on the internet is called ROT13, which just means rotate the letters 13 places. So adding 13 to H and I gives us U and V. If you got too close to the end of the alphabet, you just wrap around from Z to A. And in fact, one of the challenges for this coming week's problems is to figure out, if you're encrypting something with letters of the alphabet that are a little later, how do you indeed wrap around, so you get back to A's and B's and C's. Meanwhile, if we do something that's a little more compelling, like you wanted to pass a note to someone in class yesteryear, 

02:08:01 and you're worried about the teacher intercepting it-- and that message is super sensitive, like, "I love you." Well, you probably want to use something bigger than 1-- maybe 13, because a teacher, upon seeing this written on a sheet of paper, probably isn't going to try, and probably isn't going to care, to decrypt it. But they could. If we're only using a relatively small key of 1 or 13 or 14 or 15, they could, if they really cared, just brute force their way through it. And this is actually a technical term, much like in yesteryear, using a battering ram to brute force your way into a castle door, for instance. Brute force digitally means try 1, try 2, try 3, try 4-- try all possible keys. And eventually, the plaintext is going to pop back out if you have enough time. So the world has much fancier encryption algorithms nowadays than this. But we begin by using this as representative of those. The math has, of course, gotten more sophisticated. This is not a good key to use. There's this internet joke for people in the know online and on Reddit. 

02:09:00 Like, oh, ROT26 is twice as secure as ROT13. Why is that funny? It's the same thing-- A to A, B to B. This just literally gives you the same message. So don't believe everything you read, for instance, online. So what about decryption? Well, in the case of the Caesar cipher, it's just the opposite. Instead of adding 1 or adding 13, you subtract 1 or you subtract 13. So for instance, here might be a message, a little different from the one with which we began, whereby if we subtract 1 from each of those, we can decrypt this. So for a final flourish here, and for a taste of what lies ahead for problem set you subtract 1 from U? What do you get? STUDENT: T. DAVID J. MALAN: T, and then? STUDENT: H. DAVID J. MALAN: H, and then I and then S and then-- ooh, W, A, S T, S. And this was CS50. We'll see you next week.
