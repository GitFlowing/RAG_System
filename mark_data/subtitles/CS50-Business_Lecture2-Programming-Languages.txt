00:00:00 SPEAKER: So what does it mean to program a computer? At the end of the day, programming is all about writing software, or coding, so to speak. And this means writing english-like syntax into a text editing program, something like Microsoft Word, but simpler, in such a way that the computer ultimately can understand the english-like syntax that you're writing. Now, it turns out there are so many programming languages in the world-- indeed it can get completely overwhelming as to how many there are, and which one you choose, and one you should use it, and how you should recruit someone who actually knows a particular language --but nicely enough, there are some fundamental constructs and fundamental ideas that underlie most programming languages, so that once you start to understand and pick up those fundamentals can you apply that fundamental understanding to almost any language in the world that you might subsequently learn. Now there's certainly some technical differences among languages, 

00:01:02 and there's certainly some historical differences among languages, because the reason that we have so many languages is because humans are constantly getting better at writing software. Humans are constantly figuring out, oh, gee, wouldn't it be nice to have my language have some other feature so that it's easier for me to get real work done? And so as in the past when you see this sort of layering of more and more sophisticated, more and more featureful tools being layered on top of the simpler of the tool. So today, like always, we'll sort of start down here, work our way up, and then realize here after can you apply most of these lessons learned to yet other contexts still. So what are some of the constructs that you might see in many programming languages? Well, let me propose a few new vocabulary words. Functions, loops, variables, conditions, and there's even more than that. And you might recognize, of course, some of these terms from different contexts, but what do they mean? Well, what does it mean to program a computer? It means to write some instructions that tell that computer what to do. 

00:02:02 Now, if I pretend for a moment to be that computer, albeit in human form, what kinds of things could you tell me to do if you were the programmer commanding me to follow your instructions? Well, perhaps here as I stand with two feet on stage, one of the simplest things you could command me to do by saying it verbally or typing it out for me is to say, move. And so if you were to command me to move, I might take a step like this. Now, that wasn't all that productive, I didn't make my way very far. But if you commanded me again to move, I might take a second step, like this. But that quickly becomes tedious telling David, move, move, move. I mean, that's not a particularly compelling way to program, so wouldn't it be nice to tell me to do something again and again and again, but much more succinctly? For instance, if you'd want to tell someone in the real world to do something again and again, you don't just keep saying it presumably again and again and again, you might say instead, hey, David, move five times. 

00:03:00 One, two, three, four, five. And so more succinctly, albeit in English, can you get me to do something again, and again, and again. And that something is the same thing. And so in the context of a computer program, we might call move, the act of me moving from one spot to another, a function, a procedure. Really an action, a verb-like construct that's just doing something. And a loop, meanwhile, as the word rather suggests, is this notion of doing something again and again, cyclically, so to speak. And even though I've done it thus far in English, saying, David, move five times, you can translate this intuition ultimately to programming languages as we'll soon see. Now, meanwhile, a variable you might recall from a context like algebra. X, or y, or z. Now, it turns out in many programming languages, do have variables as well, and it turns out you can name them in a more interesting way than x, y, and z. In fact, you might name a variable counter, if you wanted to keep track of how many steps you have taken. 

00:04:00 So for instance, if someone commanded me, the computer in this story still, to just move forever, I could move forever. And this is not going to end well at the end of the stage, but simultaneously could I create a variable in my mind called counter, or x, or y, or z, whatever, but counter is more descriptive, and I could keep track of how many times I'm moving while moving indefinitely. So counter is 1, 2, 3, 4, 5, 6, 7, But loops indeed can be infinite. They can run forever for better or for worse. And as an aside, if you've ever noticed your computer kind of spiraling out of control whereby it's the beach ball is spinning, or the little hourglass, or the like, it might very well be that your computer is stuck in an infinite loop, doing something again and again and again that maybe is deliberate, like a clock ticking forever, sometimes loops can be good if they tick forever, but sometimes it can be a bug. A mistake, in a program, as we'll soon see, that a programmer, a human, did not anticipate. And so a program just keeps running and running and running, 

00:05:02 consuming all of your computer's resources, or memory, or CPU, and so you can't really do useful work on it. So loops can be both good and bad in contexts like that. And then conditions. A condition is a way for me to fix this problem. For instance, I might be told by a programmer, move forever, but if you're about to walk off the stage, stop. The operative word there being if. So irrespective of variables, I might just be moving, and moving, and moving, and constantly checking if I'm nearing the edge, am I at the edge? Am I at the edge? Am I at the edge? Oh, I am, and so I should stop. So if I am about to step off of the stage, I should stop. And so I can conditionally fix this kind of problem. And there's other constructs, still, but this is to say ultimately that programming, or coding as it's commonly called, but the terms are pretty much interchangeable, is really just this process of translating this human intuition to a language, a textual language, a typed language, 

00:06:00 often, that a computer understands. But there's many different ways to speak to a computer, much like we have so many different spoken languages. We humans among cultures, among countries, within countries, so do computers understand different languages, so long as humans have kind of sort of taught those computers to understand those languages. Which is to say that when you buy a Mac, or a PC, or whatever, it doesn't necessarily come with some built in support for a whole bunch of programming languages. The end of the day, it's going to understand binary, zeros and ones, and it's going to understand a so-called instruction set, whereby Intel, or whoever makes the CPU inside preprogrammed it to understand certain instructions like add, and subtract, and move, and load, and so forth. But beyond that, it doesn't necessarily know how to do all that much with your human instructions, unless you or some company, someone, has taught it to understand other languages. And so there are languages called assembly language, there's something a little easier to read called C, 

00:07:02 then there were languages like C++ and Objective-C, and now there's Perl, and Python, and PHP, and Ruby, and Java, and JavaScript, and so many others still, but those are the results of humans over time writing software that can run on Macs and PCs that allows the computer now to understand not just zeros and ones, but higher level languages. Things that humans can express much more pleasurably and easily than just zeros and ones alone. And these languages don't have to be textual, it turns out. In fact, when first exploring programming and programming languages more generally, I daresay it's more straightforward, and perhaps a little bit more fun, to actually sort of program by way of pictures, if you will, by way of puzzle pieces, we'll call them. So pictured here is perhaps one of the simplest programs you can write. And it's sort of entered into history as one of the most canonical programs you can write, demonstrative of what you might do in a language on your first day. 

00:08:01 And it just says, in this context, when green flag clicked, say, hello, world. Hello, world, being the buzz phrase that permeates most of programming history these days. This is a program that if you run it with the right software on your Mac or PC, will actually print the message on the screen, hello, world. And what's nice is that it doesn't quite look like other languages, which we'll see soon are very textual, and are a little arcane, a little harder to wrap your mind around because there's so much punctuation that they tend to have, but we can explore for just a bit here programming, by way of this graphical language called Scratch, via which we can see some of these same ideas. Functions, loops, conditions, and variables, and more come to life, so to speak, on the screen. So let me pull up exactly this program called Scratch. And there are four main areas to this particular program. It's freely available software, and you can also access it via the web, though I'm using a downloadable version here. And you'll see at left, perhaps most obviously, this cat, who goes by the name Scratch. 

00:09:00 Scratch here is an example of a sprite, which is a term in the world of computer graphics that refers to some kind of entity, often some kind of character, that can do things, maybe move up, down, left, right, or the like. Meanwhile on the right hand side, there's this blank slate, this big canvas, the scripts area where eventually I'm going to able to drag and drop some programming pieces, some puzzle pieces, in order to get this sprite to do something. And the pieces I can drag and drop and use are these here in the middle. And there's going to be way more than we even look at right now, but you'll see that they're categorized and also colorized by category, so we'll play around for just a bit with some of these sample constructs, and see what we can't do. So in fact, let's see if we can't translate my human example to a cat. Hopefully that's not too much of a leap here, and let's see if we can get Scratch to do something quite akin to what I just did. So I know from having used this software before, that I probably want to start with this events pallet up at top right in the middle of the screen. And you'll notice if I zoom in, there's a whole bunch of puzzle pieces here, 

00:10:01 but only one that looks familiar thus far when green flag clicked. What is that green flag referring to? Well, if we look at the stage over here on which Scratch lives, notice in its top right hand corner, there's both a green flag, which is going to mean go, and a red stop sign like thing that's going to mean stop. So those are going to be the two buttons via which we can start and stop my program. So kind of equivalent in your Mac and Windows world to double clicking an icon to run some program. So if I now zoom out, notice I can click on and drag this when green flag clicked puzzle piece. And I can put it wherever I want, but much like in English, I might start at the top, and work my way down and to the right, so I'm just going to let go. And you'll see now that it's plopped itself there, but it's not going to do anything, because all my program is saying, literally, is when green flag clicked. It's kind of a cliffhanger. We need to attach some other puzzle pieces there. And the puzzle piece we saw a moment ago was something that looked like this. And here we have a new palette, the looks palette. There's so many purple puzzle pieces here, 

00:11:00 but I'm just going to go ahead and grab, say, one of them, which by default says, hello. But notice, this puzzle piece as I pull it over to the other puzzle piece, notice how this little white line appears sort of magnetically. It's because these two puzzle pieces, as per their similar shapes, want to snap together. And if I let go, notice indeed, the puzzle piece does automatically connect itself. And if I don't want to just say hello, exclamation point, but just more subtly, hello, comma world, I can just click in that white box and type my new text. So now consider what this is saying. When green flag clicked, say, hello world. And it kind of flows logically, much like it did verbally as I was programming myself a moment ago. So let's go ahead and click the green flag. We're programming. We've just run the program, it has stopped, and notice he's still saying, hello, world, because the computer, in many contexts, is going to take you pretty darn literally. And the fact that I didn't do what, explains why he's still saying hello? 

00:12:00 Right, I never told the computer to stop saying hello, or stop the program explicitly, and so it's going to keep doing this until I command it otherwise, as by stopping the program outright. Now, meanwhile, we had movement. So it's one thing to have a function, an action, like say. What if we wanted to have Scratch actually move? So let me get rid of this purple puzzle piece, and just drag it and let go. It will just disappear if you drag it over to the middle. And now I kind of want to control the functionality of my program. So if I click on the control palette here, you'll notice a whole bunch of yellow puzzle pieces, one of which is forever. And that kind of connotes exactly what we're looking for, this notion of doing something cyclically, again, and again. It too wants to snap together when I let go. And now this seems a little unfortunate. Darnit, if this forever block doesn't leave me with just barely any room for other puzzle pieces, but no problem. The software that our friends at MIT wrote here for Scratch is going to automatically grow that block as needed once I start inserting new pieces. So I want to move. Motion sounds about right. 

00:13:02 And indeed, there we go, move 10 steps. Let me go ahead and put this inside, and notice this white line appears magnetically. I let go, it grows to fill it, and snaps into place. Let's just do one step as before, and we'll see in just a moment what I've done. Let's go ahead and click green flag. It's a little underwhelmingly slow, but he's literally doing what we told him to do one step at a time. Thankfully, MIT had the foresight to make sure that scratch can never leave the screen completely, otherwise it's kind of a frustrating experience. So you can always kind of grab onto his little tail here, but notice the program's still running. So even if I drag him and let go, he is still forever moving one step over, and so we'll see him going there again. But you'll notice a moment ago, I actually didn't really know necessarily where I was going to find the puzzle piece of interest to me, and even as I here to have to give some thought as to where these various puzzle pieces are, 

00:14:01 this is actually representative of how one might learn a new programming language for the first time. Once you understand some of the fundamentals, can you much more readily start to pick up what you need to know. Can you fill in the gaps in your knowledge? And thanks to Google, and Bing, and any other search engine out there these days, and any number of websites like Stack Overflow, and Hacker News, and the like, are there so many technical folks out there who can help you by answering questions for you, who have posted long ago answers to questions that you can rely on. And so indeed, the process of learning how to program these days, once you have a solid foundation in one or two or more different types of languages, really allows you to bootstrap yourself and figure out something new. So even as you might dive into an environment like Scratch, you realize and take comfort in the fact that you don't have to have known or seen every one of its features. Simply by pointing, and clicking, and trusting that you're probably not going to do much damage to the computer or to the program by just tinkering, can you really start to explore. And indeed, that's where a lot of the fun of programming starts to come out. Now, with that said, this program seems to be 

00:15:03 arguably buggy, and so far as it's kind of lame, if nothing else, that Scratch ends up walking pretty much off the side of the screen. Wouldn't it be nice if just like my example where I was about to walk off stage, but thanks to a condition, I didn't, can we prevent that kind of disaster? Well, let me go ahead and go into the control block, I think. And yep, indeed, there are not only looping constructs like forever, and then also notice repeat, where you can specify a finite number of times to do something again and again. Notice that there's this here, if then. And you know what? I don't want to move no matter what, I want to move, but then check immediately if I'm touching the edge. And here, too, I might have to do a little digging to figure out what this language can do, but I think if I go under sensing, ah, touching. And notice touching currently says mouse pointer, which isn't quite what I'm looking for. I'm looking for the edge, touching the edge, but sure enough, if I go ahead and click this drop down, I can change this puzzle piece to ask a question. 

00:16:00 Are you touching the edge? And this puzzle piece and the several below it are an example of what we might call a Boolean expression, named after someone by the name of Boole. And a Boolean expression is an expression, a statement, a question, whose answer is either yes or no, true or false, one or zero. And this is the perfect construct, therefore, to put inside of a condition, the proverbial fork in the road, or a branch so that you can decide based on that condition exactly what you want to do. So all that remains is for us to drop into place the Boolean expression via which we can answer the question, are we touching the edge? So indeed, let me go ahead and drag and drop this blue puzzle piece right on there. And notice, it too doesn't seem to fit quite right, but it's going to grow to fill. And now notice inside of the if condition, we have an opportunity to slide in one or more other pieces. So what do we want to do? Well, let me go to motion as well. And let's see, if touching edge then, let me go ahead and turn some number of degrees. 

00:17:02 I don't think 15 degrees is going to do it, so you notice that's a bug, the cat is still going. Let me go ahead and hit the stop sign there. But we probably don't want to have him turn only 15 degrees, we probably want him to reverse his direction entirely. So I think that's going to be 180 degrees. So let me go ahead and make that change, and then movement, he's going a little slow, but that's OK. So let me go ahead and drag him back to the middle of the screen, click our green flag, and really cross our fingers as is not uncommon in programming, and come on, come on. All right. All right, so still arguably a little buggy. I didn't really intend for him to go upside down, but he indeed literally did turn around 180 degrees. And there too, that's kind of a key takeaway, is that in most any programming language, the language, and in turn the computer, are only going to do literally what you tell it to do. So if I simply told Scratch to sort of turn 180 degrees, that's exactly what he's going to do. He's not going to reorient himself as a reasonable human being might, we would have to write that code. 

00:18:01 Now, meanwhile this gets very boring quickly, so how might I speed him up? Well, consider what it means to speed up, and consider in fact what animation really is whether in comic book form if you flip through the pages really fast, or if you watch a cartoon on TV or online, animation really is just the process of showing me one thing after the other really quickly, typically. Now, this is not all that quick, but what if I told Scratch to take not just one step at a time, one small step at that, but like 10 steps at a time or the equivalent of 10? I can't really move my feet that quickly so we'll pretend, but I can tell Scratch to start moving not one step at a time, but, say, 10. And he immediately starts to balance a little more animatedly. Now, we can have a little bit of fun with this. So a little bit of a intellectual aside, if we go to Scratch's sounds feature like this, let me go ahead and first stop scratch here, let me go ahead and click the microphone to record a new sound, let me click the record button, ouch. 

00:19:01 All right, so that is a wave form of what the word ouch looks like when I say it. I'm going to go ahead and delete the dead air up front, and a little bit of the dead air here. I'm going to change the name to, let's call it ouch. And what's kind of fun now is if I go into a sound, notice that ouch is among my available sounds. Now, when do I want to play ouch? It's kind of a condition too. Only if I have walked into the stage do I want this to sound out, so let me go ahead and drag it in here. And now let's consider before we get to the finale here, what's going on? When green flag clicked, do the following forever, again, and again, and again, move 10 steps. And that's what was getting Scratch to move pretty quickly, but then every time you take those 10 steps, take a moment to check if you're touching the edge, then turn around 180 degrees. But one more thing to do now, because again, both the blue and the purple block are inside of this yellow if branch, we're going to do both of those. 

00:20:00 So in theory, what Scratch is going to be doing, is as he walks again, and again, and again, and again, and again, and he finally gets to the edge, hopefully he's going to turn around 180 degrees. But a little more literally than I, the human might do. So let's try this. Oh, and actually, I left out one detail that Scratch will not. Ouch. Ouch. Ouch. Ouch. So ironic that the cat sounds more like me than I do when walking into walls. So that there is Scratch. It's just one programming language, and it's graphical at that, and we've only scratched the surface of its features. And indeed, there's more sophisticated things that we can do in order to program even more animatedly, even more sophisticatedly. And in fact if we skim ahead to one of the first programs I wrote back in the day, let me go ahead and show you something called Oscar Time. Here is Oscar Time, and you'll hear in just a moment as I hit play, not only does this have animation, it's also got an incredibly long song, which long story short, was not the best design decision back in the day, 

00:21:00 because as I worked through all of this program's bugs, all I heard was the Sesame Street song for I think eight or more hours, but I have very fond memories nonetheless, and this then is Oscar Time. So what's worth noting now? It looks fairly simple at first glance, we have some static imagery at left, a trash can, what's in there I wonder? And then a piece of trash that's falling. But this is an opportunity to consider how is that piece of trash falling? Well, it's some kind of sprite. And indeed, in Scratch, you can have more than just a cat, you can have other animations on the screen as well, but what was happening with that piece of trash? Well, odds are I had it positioned originally at the top of the screen, and there's a puzzle piece that will do that, and then I had it moving one or more steps at a time in a loop. But then here instead of bouncing, which would be a little strange if your trash is just kind of bouncing up and down off the ground, I just have it stop. So there's probably a condition in there as well. I talked over another object that was falling, 

00:22:00 but there's another sprite, this blue sneaker, that also fell from the sky, but from a slightly different place. And it turns out in many programming languages can you use randomness, or really pseudo randomness that the computer simulates, and so that's why the shoe, or the sneaker, actually fell from a different location. And if I kept playing this game again and again by restarting, odds are that trash, that sneaker, and now that newspaper would fall from different locations. So if you've ever played a computer game or game on your phone and it's not the same experience every time, something kind of sort of changes, like the monsters start from a different direction, or the bad guy gets even harder or easier depending on your level, that might be the result of some pseudo randomness. Asking the computer to just kind of pick a number, or pick a location, and then do something with that so that the game is constantly changing. Now, this is not all that interesting if all I wrote was a program where trash is falling from the sky, but notice what you can do. You can grab things like the clock, click and drag, and notice, this too is probably a condition. If near the trash can, open the lid. And again, here's the finale, nope. 

00:23:01 Here is the finale. As the trash falls into the can properly, does Oscar pop out and start counting. And indeed, if you do this again, and again, and again, it would seem that Oscar is using what? A variable. And indeed, that's how he's keeping track of the score, as might most any computer game. Now, you can absolutely program games, animations, interactive pieces of art in a language like Scratch, and it actually indeed by design, has a pretty high ceiling. You can write some pretty sophisticated programs way more sophisticated and impressive than the one I did back in the day. But what's exciting about that is that it's the result entirely of again, this layering. Using some very basic constructs, some simple ingredients, some building blocks, literally, whereby you build on these fundamentals of functions, and loops, and variables, conditions, Boolean expressions, and even more. And then so long as you take sort of baby steps, so to speak. Biting off just a little piece of functionality, just get the trash to appear on the screen, 

00:24:00 then just get the trash to move on the screen, then get the trash to stop moving on the screen when it hits the ground can you begin to take steps, and steps, and steps toward your final solution. But what's key in programming is to compartmentalize some of the features and to do them piecemeal, so that you don't just sit down with a blank window in front of you trying to bang out the whole entire thing. Because invariably, if you're like me, the thing is going to be riddled with mistakes, otherwise known as bugs. Because it's a little too hard to see everything clearly if you're not testing, and testing, and testing perhaps along the way. But what do most people program in these days? Well, you can use Scratch, but generally speaking, someone's going to use a higher level, a more traditional language that tends to be textual, and not graphical. So it's a wonderful environment to learn programming in, it's a wonderful environment to teach programming in, but you can very quickly take off these proverbial training wheels, and start to use something a little more arcane, yes, but a little more powerful, at the end of the day. And one of the earliest languages that was not binary 

00:25:01 and was not something called assembly language, was this language here, called C. Now, this program too, quite simply as you might guess, prints, hello, world. That's it. But there's a lot of overhead syntactically. I see weird curly braces, and parentheses, and a semi-colon, backslash n. There's a lot of magical incantations here that would seem to suggest complexity, and yet all I want to do is just print out, hello, world. But C is representative of a type of language and a type of programming experience that's pretty representative of lot of different languages as well. But the computer isn't going to understand this right from the get go. We're going to have to first convert this language, this language C, into those zeros and ones that the computer does understand. And the means by which we do this is typically as follows. I write in a language like C, what we'll generally called source code. This is simply text, like the lines you just saw a moment ago, that ultimately just say, hello, world, but with some syntax around it to make that all happen. 

00:26:00 But the computer doesn't typically understand source code. It understands zeros and ones, otherwise known as machine code. So machine code is what the machine understands, and source code is what the source, me understands. There's got to be something in the middle. And indeed, there's typically a program in the middle called a compiler, whose purpose in life is to take source code as input, and produce machine code as output. So before I can run a program like that, I have to run another program on my computer, called the compiler. Might be called Clang, it might be called GCC, it might be called Visual Studio, it might be called Code Blocks. There's so many different compilers out there, but at the end of the day, what they fundamentally do is take one language as input, and output another as output, and generally in a way that your operating system and your CPU both understand. But what does this machine code look like? Well it literally will look like zeros and ones. And indeed, if I run this source code through a compiler and don't run it 

00:27:01 but look at it with a special program, I will actually see patterns of zeros and ones exactly like these. And even I, the human, in looking at this don't really know what they represent. I could maybe convert it to ASCII, but that's not really going to get me anywhere. I would have to pull out my instruction manual from the Intel CPU inside my computer to actually understand most of these patterns of bits. So I'm not going to go to that extent, this is why we have higher level languages like C. But again, this isn't all that pleasurable to look at, to write, it requires a bit of cognitive overhead to remember all of this. There are simpler languages like this one here, Python, where thankfully, you just say what you mean. Now, there's still a little bit of syntax, there's some quotes, there's some parentheses. But at the end of the day, it's really far more so just the word print, and just the sentence, or phrase, that I want to print. Gone are all those curly braces, the requisite semi-colon, and more, and so certain languages are a little simpler. And indeed, Python and other languages are the result of programmers, and humans, more generally, having learned, 

00:28:02 gee, wouldn't it be nice if this were a little simpler. Wouldn't it be nice if this language did a little more of this work for me, made certain assumptions for me so that you don't have to write and remember as much complexity as we saw a moment ago. But Python's an interesting one too, because it is generally interpreted, so to speak. And that's a bit of an oversimplification, but when writing code in a language like Python, we again still have source code, just as we saw a moment ago, print hello, world, but you don't convert it to machine code per se, at least not explicitly. Rather, you run it as input into a program called an interpreter, whose purpose in life is to do exactly that, to interpret the lines of code that you've written, top to bottom, left to right, and actually translate them, essentially, into the language that the computer can understand. And it does this though not by converting them to zeros and ones, but by outputting something called byte code, which is an intermediate representation of the language. 

00:29:01 So it's much more cryptic as we'll see in just a moment, but it's not as cryptic as zeros and ones, and so when you use a language like Python and others like it, you will often install a special piece of software, whether you realize it or not, called a virtual machine, or VM. And that virtual machine is kind of like an imaginary CPU that can work on Macs, and PCs, and other computers still, that someone out there has written that understands byte code, and the virtual machine in turn is what is running at the end of the day. And it's running your byte code, which is the result of your source code. And long story short, even though this looks like a more complicated process, what's nice about this process in many of these newer languages is that a lot of these intermediate steps are completely hidden from you. If you want to write a program in Python, you simply write it as source code, and then you run a command at your keyboard, and that's it. There's no explicit compilation process that you have to worry about as the programmer. 

00:30:00 The computer might be doing that for you underneath the hood, and indeed it is, but it's been obstructed away, so to speak. Now, let's see these two examples in action, but first, the intermediate language that Python is going to generate in order to be run on its virtual machine is this byte code here, something that looks a little bit like this. You can kind of sort of figure out what's going on. I see print, I see hello, world, but there's some other stuff that I don't necessarily understand at first glance, but that's OK, because the virtual machine that's going to run this ultimately will. So let's see this in action. I've gone ahead and opened up a terminal window, so to speak. Really a black and white window on my Mac, or PC for that matter, that has some software pre-installed, software that does understand C, and Python, and even some other languages as well. I'm going to go ahead and open a program called Nano, which is just a simple text editor, and I'm going to open a file called hello.c. And not to worry about what some of the syntax on the screen here is, what's important is that I'm going to retype the same thing we saw a moment ago, include standard I/O. Int main(void), and then in here, I'm going to do printf("hello, world/n");. 

00:31:05 So I have just recreated that program in C, and I'm going to go ahead and save it in a file called hello.c. So all I've done is opened the textual equivalent of Microsoft Word, but a super light and less friendly version perhaps of it, but that I've used many times before. I'm now going to go ahead and type the following. Clang, for C language, -o hello space hello.c. So again, another one of these sort of magical incantations that I understand because I've done it before, but you could read this in a manual or be taught this in a class, and what this is telling my Mac to do is to compile hello.c into a new file called hello inside of which are those zeros and ones. If I go ahead and hit enter, nothing appears to have happened, but if I now type this command, dot slash hello where dot just means go into my current folder, and hello means run the program called hello, we shall see if I did this right, hello, world. 

00:32:01 Underwhelming result, but a correct result, but it did take a few lines of code and a bit of complexity. If I instead run Nano of hello.py, where py is commonly the extension for a Python program, and instead I literally just type print("hello, world");, and then save this file, and now run Python, hello.py and hit enter, you'll see the exact same results with arguably a decent amount less effort. So these are just two languages now. There are so many others out there. For instance, here we have an example of this same program, fundamentally hello, world, in a language called C++, which essentially adapts C, and adds some new features to it while changing a few things as well. And you can see the syntax alone is already a little bit different by convention. Here's an example of hello world in Java, a very popular language formally in the context of little things called applets on the web, more recently in enterprise software on the backend for servers as well, as often commonly used as a teaching language with students in school. 

00:33:00 This here is an example of a language called Ruby, which is often popular at the command line in that black and white environment, where you're running commands with your keyboard, as well as in a web context using a framework called Rails, or Ruby on Rails, if you've heard of that. Lastly here is another example, this one in a functional language called Lisp, whereby you tend to have more parentheses, and it's what's an example of a functional language, which doesn't just mean that it functions. It's a fundamentally different type of language than the others we've looked at thus far, which are procedural, or imperative, which is only to say it's a somewhat different mental model when it comes to programming in languages like this, but you can still print out things like hello, world, quite simply. And then there's JavaScript, which exists in a number of contexts today both in the context of the web browsers, but also in web servers. This is how you might, on the server side, print out something like hello, world. But JavaScript is an interesting one too, because there's newer and newer features of the language itself. And this is true of a lot of languages, they evolve over time. So humans don't just invent new languages, 

00:34:02 they sometimes go back and improve on and increase the version number of past languages by updating the tools that understand them. So Clang, like I ran a moment ago, which was my compiler, and Python, which I ran a moment ago, which was my interpreter, and coincidentally also the name of the language. Those can continually be updated. You can download and upgrade versions of those, and they'll support newer versions of the language, and so it's very common these days for JavaScript to actually be newer than is actually supported by browsers out there. And so a common term of art in this world now is to transpile. Not compile, but transpile JavaScript to JavaScript, specifically from a newer version of JavaScript to an older version of JavaScript, maybe like English to old English, simply because the browsers of today don't necessarily understand the newest version of English, they're still speaking something from yesteryear. So there's any number of methodologies, there's any number of languages you might use, and indeed, this is just a few of them here. 

00:35:01 You might recognize some of these names here. Many of these are increasingly used in the web context to actually build websites, to build mobile applications, to build things that are optimized for your phones, but the dot dot dot's just we're really just scratching the surface. And if you've ever wondered what more there is, let me invite you to go to Wikipedia or beyond, and you'll see an overwhelming list of languages and also a lot more of the history of these and many other languages. But of course, the examples we've done thus far have been in the graphical context like Scratch, they've been in the textual context like C and Python, what we haven't done is actually leveraged the worldwide web. We've not actually written a program that runs on my phone, it would seem. We've not yet written a program that runs in my web browser, on my laptop or desktop. To get to that point, we're going to need a few more ingredients, a few more building blocks, if you will. Languages like HTML. Not a programming language, a markup language, but it's the language in which web pages are written, and it provides us with a new and improved context, perhaps, for writing software using the same ideas, 

00:36:02 but with different user interfaces on the phone. But to get to that point, we're going to need to understand a little bit about that other language, HTML, we're going to need to understand a little bit about the world wide web, and ultimately, we're going to need to understand how the internet itself works.
